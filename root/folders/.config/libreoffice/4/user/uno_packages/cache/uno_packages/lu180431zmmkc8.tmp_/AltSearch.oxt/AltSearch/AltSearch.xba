<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="AltSearch" script:language="StarBasic">REM  *****  BASIC  *****
&apos; Alterantive Find &amp; Replace for OOo Writer
&apos; Alternativní Najít a Nahradit pro OOo Writer 
&apos;
&apos; Autor: Tomáš Bílek – © 2007 – macrojtb@volny.cz
&apos;
&apos; Tento program je svobodný software; můžete jej šířit
&apos; a modifikovat podle ustanovení GNU LGPL.
&apos;
&apos; Je rozšiřován v naději, že bude užitečný, avšak BEZ JAKÉKOLI ZÁRUKY.
&apos; Originální text licence GNU LGPL najdete na http://www.gnu.org/licenses/lgpl.html
&apos; ------------------------------------------------------------------------------
&apos; This library is free software; you can redistribute it and/or
&apos; modify it under the terms of the GNU Lesser General Public
&apos; License as published by the Free Software Foundation; either
&apos; version 2.1 of the License, or (at your option) any later version.
&apos;
&apos; This library is distributed in the hope that it will be useful,
&apos; but WITHOUT ANY WARRANTY; without even the implied warranty of
&apos; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
&apos; Lesser General Public License for more details.
&apos; http://www.opensource.org/licenses/lgpl-license.php
&apos;
&apos; You should have received a copy of the GNU Lesser General Public
&apos; License along with this library; if not, write to the Free Software
&apos; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
&apos;
&apos; ******************************************************************************

option explicit

public const verze = &quot;v1.4.2  3/2017&quot; &apos; 14.11.2015
public const errControl = true &apos;false &apos;true  &apos; zapína vlastni obsluhy chyb - pro ladění false - jinak nutno true - pro správnou reakci na chybu regionu a pod. ve FindNextInBlock
global ICUcompatability  &apos; = true &apos; reakce na ICU v regualar expressions (International Components for Unicode): \xhhhh =&gt; \uhhhh =&gt; akceptuje oba způsoby
dim initError &apos; pocitadlo opakovanych chyb inicializace kurzoru
global AltSearchIni(12)  &apos; prvrk 0 boolean - priznak, ze už byl predtim spusten = nacist ini hodnoty
global AltSearchFind(0) as string  &apos; historie hledaní
global AltSearchRepl(0) as string  &apos; historie nahrazení
global AltSearchDoc, AltSearchDocControl, AltSearchKbd, AltSearchDialog  &apos; pro kontrolu obsluh v jinych oknech apod. 
global AltSearchContainer  &apos; kolekce pro hledani v poznamkach a polich - prozatim pokusne
global AltSiniSel &apos; vyber pri spusteni 
global AltSearchSkup(12) as string &apos; pole s texty nalezených skupin 
global hle(), hle1(), hle2(), repl()  &apos; pole s parametry pro hledani hle() bez skupin, pro zrychleni hledani, hle1 a hle2 je pro bigblock
global AltSLastFound  &apos; kod vysledku posledniho hledani: 0=nalezeno
global oSels, oDocControl
global msg(60) as string
global AltSearchDialog_end
global AltSearchFindLast &apos; posledni výraz hledaný pomocí findNext
dim AltSearchPrintOut as string &apos; aktivace vypisu do souboru \R - jmeno souboru - okna
dim oPOfile as object &apos; objekt souboru pro vypis 

dim AltSearchMFind(), AltSearchMRepl() &apos; pole pro jednotliva hledani a nahrazeni v rezimu multi
dim nCount as long, ReplCount as long, BatReplCount as long &apos; pocitadlo nalezenych vyrazů, počitadlo záměn find all, pocitadlo zamen pro davky
public foundAll as variant&apos; kolekce po zrychlenem vyberu - je bud 0 nebo objekt, podle vysledku zruchleneho hledani, je-li nula tak nutno pouzit vyberu nalezeneho pomoci BackColor
dim varovani as boolean  &apos; umozni zobrazit varovani pred moznosti poruseni zvyrazneni
dim dispatcher as object
dim dispathArgs(0) as new com.sun.star.beans.PropertyValue
dim errProp as long &apos; počitadlo neuspesnych nastaveni properties

&apos;dim  oDoc
dim oDial &apos; hlavni dialog
dim oDsel &apos; dialog vyberu stylu
dim oDmof &apos; dialog pro vykonání dávky na vice souborech
global oDialSh  &apos; dialog klavesovych zkratek
dim prvnipruchod as boolean
dim IsBatchInit as boolean  &apos; priznak provedene inicializace batch modulu
dim quitMode as boolean
dim outMsg as variant
global SrchAtr() &apos; as new com.sun.star.beans.PropertyValue  &apos;pole s atributy pro hledani 

global ListOfWFiles() &apos; seznam otevřených souborů writeru 
global ListFilesForBatch &apos; seznam vybraných souboru pro spuštení dávky
global BatchToExecute &apos; jmeno dávky pro vyhkonání na více souborech 
global CountBatch, CountBatchSel &apos; Počitadla
global oBatchDispatch  &apos; dispatch pro spustení davky pres pomocnou proceduru
global MultiFileBatchRun as boolean  &apos; příznak že probíhá davka na vice souborech
global MultiFileBatchReport as string &apos; celkový report 
global MultiFileBatchDisableMsg as boolean &apos; potlačení dílčích reportů po každém souboru

global prCurs, prCurs1 &apos; skryte kurzory
dim fo1, fo2, fo3, fo0 as object &apos; nalezene bloky: poc. znacka, blok mezi znackami, ukoncovaci znacka
dim fo1s,fo2s,fo3s as string &apos; retezce odpovidajici poc. znacce, vloku mezi a konecne znacce big-bloku
global ovCurs, ovCurs1 &apos; viditelný kurzor, 1 pro soubor výpisu
dim findPageBreak as integer &apos; 1 pageBreak, 2 ColumnBreak 0 = nehledat pagebreak
dim findReg(), findExt(), findAtr(), replExt()
global initImplName &apos; implem. jmeno vybraneho objektu 
&apos;dim dispatcher as object
dim findcounter as long &apos; počítadlo odstavců při hledaní \p \m \c, pro ukazatel stavu hledani a přerušení běhu
global tmppole(), tmppole1() &apos; pole používane pro poznamky, footnoote, a text. pole
global language as string
dim lng as byte &apos; index jazyka pro dávkové zpracovaní - 0 čeština, 1 - angličtina asi i pro případné ostatní jazyky
dim helpPath$, userPath$, LastName as string  &apos;cesty k helpu a user dir; posledni uzite jmeno davky
dim textFields as boolean   &apos; přiznak pro aktualizaci polí 
dim noInit as boolean &apos; true = zakaz aktualizace kurzoru - pro hack nefunkce setFocus() dialogu
public FoundBookmarkNo as long &apos; indec právě nalezené nebo zpracovávané záložky (-1 nenalezeno)

dim foundCaseType &apos; 0=bez uprav, nechat být; 1=první velké; 2=všechna velká;  - číslo určující při nalezení retězce jeho typ z hlediska velikosti znaků
dim HelpKeyModif as integer


type tVolby &apos; struktura pro uchovani parametru dialogu hledani i mimo dialog
  kcase as byte
  word as byte
  styl as byte
  reg as byte
  csele as byte
  zpet as byte
  preservecap as byte
  
  find as string
  repl as string
  
end type

global AltSearchVolby as tVolby  &apos; pracovni promenna pro volby hledani


sub   loadlanguage  &apos; nacte retezce pro jazyk  
  if (language = &quot;&quot;) or (language = &quot;Auto&quot;) then  language = GetStarOfficeLocale_().language 
  select case language &apos; podle nastaveneho jazyka pro celé OOo
    case &quot;cs&quot; 
     lng = 0
     load_cs

    case &quot;sk&quot; 
     lng = 0
     load_cs


    case &quot;ru&quot; 
     lng = 1
     load_ru

    case &quot;es&quot; 
     lng = 1
     load_es

    case &quot;fr&quot; 
     lng = 1
     load_fr

    case &quot;it&quot;
     lng = 1
     load_it

    case &quot;de&quot; 
     lng = 1
     load_de

    case &quot;nl&quot;
     lng = 1
     load_nl
     
&apos;    case &quot;hu&quot;
&apos;     lng = 1
&apos;     load_hu 

    case else  &apos; en
     lng = 1
     load_en   &apos;load_en 
    end select
    
end sub


Sub _AltSearch(optional batchName)   &apos; spusteni hlavniho dialogu
 dim oL, oKey, loc, tmp
dim vysl
&apos; vysl = GetParFind(upravFindReg(&quot;$\p&quot;)) 
&apos; msgbox vysl.mode &amp; &quot;  &quot; &amp; vysl.txt &amp; chr(13) &amp; vysl.bmin &amp; &quot;  &quot; &amp; vysl.bmax &amp; chr(13) &amp; vysl.emin &amp; &quot;  &quot; &amp; vysl.emax
&apos;exit sub
 
  AltSearchDoc = ThisComponent
  reset_klv   &apos; pokud byla v jinem okne tato obsluha klavesnice tak uvolnit
&apos;  GlobalScope.BasicLibraries.LoadLibrary(&quot;Tools&quot;) &apos; natahnout std. knihovnu   &apos; presunuto do fromTools
  AltSearchDialog = LoadDialog_(&quot;AltSearch&quot;, &quot;D_alts&quot;)
  oDia = LoadDialog_(&quot;AltSearch&quot;, &quot;D_choice&quot;)  &apos; kvůli lokalizaci preseunuto k inicializaci hlavniho dialogu
  oDialSh = LoadDialog_(&quot;AltSearch&quot;, &quot;D_keys&quot;) &apos; dilog klavesových zkratek
  oDial = AltSearchDialog &apos; abych nemusel prepisovat ODial na AltSea...
  oDmof = LoadDialog_(&quot;AltSearch&quot;, &quot;D_morefiles&quot;)    &apos; dialog pro vykonání dávky na vice souborech
&apos;  oDial.model.Tf_name.text = &quot;&quot; &apos; nutno vynulovat, jinak se tam objevuje nechtěná podivná hodnota
  IsBatchInit = false
  AltSearchFindLast = &quot;&quot; &apos; posledni výraz realně hledaný pomocí findNext

  dispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;) &apos; kopirovani pres clipboard

  redim tmppole() &apos; resetovat pole používane k hledani rámců, poznamek, footnoote, a text. pole

  HelpKeyModif = 0 &apos; kod modifikatoru při stisknutí tlačítka Help 
&apos;  oDial.setVisible(true)  &apos; přesunuto na začátek pro dojem vetší rychlosti zobrazení

  LoadLanguage  &apos; nacte retezce pro jazyk  


  helpPath = GetHelpDir(&quot;name.TomBil.addon.AltSearch.HelpPath&quot;)
  userPath = GetUserPath
 &apos;end if
 
 
  if AltSearchIni(0)  then &apos; pokud bylo jiz spusteno nacist historii
     &apos; nacist ini a historii hledej, nahrad
     if ubound(AltSearchFind())=-1 then 
        redim AltSearchFind(0)
       end if 
     oDial.model.Cb_find.text = AltSearchFind(0)   &apos; hledany vyraz
     tmp = oDial.getControl(&quot;Cb_find&quot;)
     tmp.removeItems(0,tmp.ItemCount)       
     tmp.addItems(AltSearchFind(),0)

     if ubound(AltSearchRepl())=-1 then 
       redim AltSearchRepl(0)
      end if 
     oDial.model.Cb_repl.text = AltSearchRepl(0)   &apos; nahrazovany vyraz
     tmp = oDial.getControl(&quot;Cb_repl&quot;)
     tmp.removeItems(0,tmp.ItemCount)       
     tmp.addItems(AltSearchRepl(),0)

     oDial.model.Ch_case.state = AltSearchIni(3) &apos; case sensitive
     oDial.model.Ch_word.state = AltSearchIni(4) &apos; celá slova 
     oDial.model.Ch_reg.state = AltSearchIni(5)  &apos; regularni vyrazy
     oDial.model.Ch_zpet.state = AltSearchIni(6)  &apos; pozpatku
     oDial.model.Ch_styl.state = AltSearchIni(7)  &apos; hledat odst. styly
     oDial.model.Ch_preservecap.state = AltSearchIni(10)  &apos; zachovat velká písmena
     
     &apos; nastavit umisteni dialogu
     oDial.setPosSize AltSearchIni(1), AltSearchIni(2), 0, 0, 3  
    else 
     &apos; msgbox &quot;prvni spusteni&quot;
     AltSearchIni(0)  = true
   end if 


  AltSLastFound = 10  &apos;kod uspesnosti posledniho hledani (0 = nalezeno) po startu preventivně nenalezeno

  noInit = false  &apos; neomezovat CursorInit()
  prvniPruchod = true
  CursorInit(true) &apos; inicializace pozic kurzoru a bloku
&apos; pokud je vybran blok zatrhnout hledani v bloku
  if oSels.supportsService(&quot;com.sun.star.text.TextRanges&quot;) then 
    if (not ovCurs.IsCollapsed) then oDial.model.Ch_csele.state = 1 &apos; pokud je vybran blok zatrhnout hledani v bloku
   end if 

  &apos; nastaví vyběr v textovem poli hledat
  setCursorSel(&quot;Cb_find&quot;,0,len(oDial.model.Cb_find.text))

  &apos; reakce na ICU v regualar expressions (International Components for Unicode): \xhhhh =&gt; \uhhhh =&gt; akceptuje oba způsoby 
  ICUcompatability = getICUcomp    &apos; funkce testuje verzi OOo, LibreO a podle toho nastaví stare nebo nove vyhodnocení Rexep 
  oDial.model.Lb2.Helptext = GetProductname_() &apos; informace o verzi OOo do bubliny
  if ICUcompatability then
      oDial.model.Lb2.label = &quot;(ICU)&quot;
    else
      oDial.model.Lb2.label = &quot;       &quot;
    end if

&apos;xray oDial.getcontrol(&quot;Lb2&quot;)

  Bt_swfind &apos; přepne do základního dialogu hledání, tj. na 1. stránku dialogu

  AltSearchDialog_end = false
  
  &apos; modalni dialog - [v.1.4.2] pokud beží dávka neukazovat ho 
   if isMissing(batchName) then oDial.setVisible(true)
  
  &apos; kvuli moznosti zjistit znovuobnoveni fokusu dialogu pridat Listener
  oL = createUnoListener(&quot;AltSearchDlg_&quot;,&quot;com.sun.star.awt.XTopWindowListener&quot;) 
  oDial.addTopWindowListener(oL)
 
  &apos; pokud je zadany parametr tak provest ihned davku
  if not isMissing(batchName) then  
     Lastname = BatchName 
     initCmd  &apos; spustit přes klávesovou zkratku
     Bt_run()
     KonecTm &apos;AltSearchDialog_end = true &apos; poté skončit
   end if
 

   while not AltSearchDialog_end &apos; nastaveno pred uvinit
     wait 300
&apos;     if (findcounter mod 50) = 0 then vypisStatusInfo()
   wend
   
   oDial.setVisible(false)

&apos;   oDial.dispose
End Sub


&apos; pro hot key Ctrl+L
sub _FindNext 
 if errControl then on error goto konec
 if AltSLastFound&lt;&gt;4 then
   if AltSearchDialog_end then nactiVolby(true) &apos; obnovit volby z Ini
   AltSearchVolby.zpet = 0
   if AltSearchVolby.find = &quot;&quot; then exit sub
   FindDo  &apos; vlastni vyhledani
  end if 
 exit sub
  
konec: 
 beep
 reset_klv
&apos; AltSearchIni(6) = 0 &apos; pozpatku
&apos; _AltSearch
end sub 


&apos; pro hot key Ctrl+Shift+L
sub _FindBack
 if errControl then on error goto konec
 if AltSLastFound&lt;&gt;4 then
   if AltSearchDialog_end then nactiVolby(true) &apos; obnovit volby z Ini
   AltSearchVolby.zpet = 1
   if AltSearchVolby.find = &quot;&quot; then exit sub
   FindDo  &apos; vlastni vyhledani
  end if  
 exit sub  
  
konec:
 beep
 reset_klv
 
&apos; AltSearchIni(6) = 0 &apos; pozpatku
&apos; _AltSearch
end sub 


sub reset_klv  &apos; pokud zustala z drivejka viset obsluha klavesnice - odinstalovat
 on error goto konec
  &apos; globalní promenne; pokud jsou definovany tak se uvolni obsluha klavesnice 
  AltSearchDocControl.removeKeyHandler(AltSearchKbd)  
  AltSearchDialog.setVisible(false)
&apos;  beep
&apos;  msgbox &quot;odinstalovano&quot;
 konec:
end sub


sub CursorInit(vynutit as boolean) &apos; inicializace pozic kurzoru a bloku

   if (findcounter &gt;= 0)and not vynutit then  exit sub &apos; pokud se hleda tak neaktualizovat
   if noInit then exit sub  &apos; tvrdý zakaz inicializace 


   prvnipruchod = true

   
   on error goto problem
 &apos;beep &apos; debug  
   vypisFoundInfo(&quot;&quot;) &apos; smazat informacni pole


   oDocControl = AltSearchDoc.getCurrentController()
   AltSearchDocControl = oDocControl
   oSels = oDocControl.getSelection()

   initImplName = oSels.ImplementationName
   
  
   ovCurs = oDocControl.getViewCursor()

&apos;   xray ovCurs 

   If not oSels.supportsService(&quot;com.sun.star.text.TextRanges&quot;) Then exit sub  &apos; goto problem
   

   &apos; uschovat pro případ chyby regionu
   AltSiniSel = ovCurs.text.createTextCursor() &apos; novy kurzor podle momentalní oblasti   
   AltSiniSel.gotoRange(ovCurs.getStart,false)
   AltSiniSel.gotoRange(ovCurs.getEnd,true)
   fo1 = AltSearchDoc.text.createTextCursor()
   fo2 = AltSearchDoc.text.createTextCursor()
   fo3 = AltSearchDoc.text.createTextCursor()
   prCurs = ovCurs.text.createTextCursor() 
   prCurs.gotoRange(ovCurs.getStart,false)

   &apos; aby funkce BtReplace mela jistotu, ze je korektni vyber nalezeneho objektu a
   &apos; predchazelo volani BtFindNext,  nastavi se pri kazdem navratu do dialogu kod vysledku
   &apos; nenalezeno=10. Zpusobi to ale asi to, ze jen pri kliknuti z dialogu na ram okna
   &apos; a zpet do dialogu, pri predtim nalezenem vysledku hledani, se pri nasledujicim
   &apos; použiti BtReplace nenahradi aktualne vybrany blok, ale najde se nasledujici vyskyt 
   &apos; Vestavene OOo hledani se v tomto pripade chova tak, ze je-li vybran nejaký blok,
   &apos; tak je považován za korektni predchozi vyhledani a přepiše se nahrazovacim retezcem.
   if ovCurs.IsCollapsed then AltSLastFound = 10  &apos; kod vysledku posledniho hledani na nenallezen 

   if AltSearchDialog_end then exit sub &apos; pokud neni dialog tak skoncit
   
&apos;   if ovCurs.IsCollapsed then  
&apos;      oDial.model.Ch_csele.enabled = false  &apos; znepristupnit volbu hledat v bloku
&apos;     else &apos; vybrán blok
&apos;      oDial.model.Ch_csele.enabled = true  &apos; zpristupnit 
&apos;  &apos;      oDial.model.Ch_csele.state = 1
&apos;     end if 

   initError = 0  &apos; nulovat pocitado opakovanych chyb

  exit sub 
  

problem:
   &apos; styl: 16=zastavit 32=? 48=! 64=info; ne/moznopotlačit; ne/prerusit cinnosti
   hlaseni1(48, false, true, &quot;CursorInit:  Unsupported selection. &quot;) &apos;&quot;This selection not supported. &quot;
   
   initError = initError + 1 &apos; počitadlo opakovanych chyb oblasti, po 3 ukoncit dialog
   if initError &gt; 2 then KonecTm &apos; ukoncit dialog

end sub








sub klik


&apos;exit sub
&apos; on error goto konec   


&apos; nepracuje spolehlive, přesněji pracuje jen málo kdy v závislosti na ???
&apos; pokusný provoz
&apos; PosunZakrytyText  &apos; pokud je kurzor schován pod oknem dialogu posune zobrazení (má-li kam)

&apos;dim oooIndex
    REM Perhaps you should create and insert a new one!
    REM Notice that this MUST be created by the document that 
    REM will contain the index.

 &apos;   oooIndex = ThisComponent.createInstance(&quot;com.sun.star.text.ContentIndex&quot;)
    
    REM On my system, these are the default values
    REM How do you want to create the index?
    REM CreateFromChapter = False
    REM CreateFromLevelParagraphStyles = False
    REM CreateFromMarks = True
    REM CreateFromOutline = False
  &apos;  oooIndex.CreateFromOutline = True

&apos;xray thiscomponent.ChapterNumberingRules.getByIndex(0) &apos;.HeadingStyleName &apos;.DocumentIndexes

&apos;xray getNameOfIndex(ovcurs.getStart.DocumentIndexMark)
&apos;xray ovcurs&apos;.ListLabelString&apos;NumberingRules.getbyindex(1)
&apos;ovcurs.ListLabelString = &quot;2.1&quot;

&apos;xray getDisplayNumName(ovcurs.NumberingStyleName)

&apos;xray ovcurs.getStart.DocumentIndexMark.getPropertySetInfo.Properties
&apos;xray ovCurs.DocumentIndexMark.getPropertyValue(&quot;UserIndexName&quot;)  &apos;.dispose &apos; .bookmarks.getbyindex(0)
exit sub

dim oBo
  oBo =  ThisComponent.createInstance(&quot;com.sun.star.text.Bookmark&quot;)
  oBo.Name = &quot;Moje&quot;
&apos;  oBo.getAnchor.setString(&quot;[Moje] &quot;)
  
   prcurs.goleft(10,true)
 
  prCurs.Text.insertTextContent(prCurs, oBo, True) 
 
 &apos; oBo.anchor.setPropertyValue(&quot;Name&quot;, &quot;prCurs.getEnd()&quot; )  = prcurs
xray prcurs &apos;oBo &apos;.getDocumentIndexes.getByIndex(0)


&apos;xray oSels &apos;.gotoCellByName(&quot;A1&quot;, true) &apos;.gotoStart(false)

&apos;msgbox twipsperpixelx &amp; &quot;  x  &quot; &amp; twipsperpixelx
&apos;xray ThisComponent &apos;.ChapterNumberingRules.getByIndex(1)  &apos;.CurrentController.frame.ContainerWindow.possize &apos;.Frame

&apos; msgbox int(oVCurs.position.x / 15) &amp; &quot;     &quot; &amp; int(ovcurs.position.y / 15)

&apos;xray altsearchdoc.gettexttables

&apos;exit sub

&apos;xray thiscomponent &apos;.currentController.selection

&apos;exit sub
&apos; xray prCurs &apos;.position
&apos;dim vSpeller
&apos;vSpeller = createUnoService(&quot;com.sun.star.linguistic2.SpellChecker&quot;)
&apos;xray ovCurs.DocumentIndexMark &apos;.dispose  

exit sub

 prCurs.gotoRange(ovCurs.getStart, false)
 prCurs.gotoRange(ovCurs.getEnd, true)
 xray ovCurs &apos;.TextField &apos;  .footnote  &apos;.TextField

&apos; xray Thiscomponent.footnotes
&apos; xray oCurs


&apos;runOOoIntCommand(&quot;JumpToPrevFootnote&quot;, &quot;&quot;, &quot;&quot;)
&apos; args1(0).Name = nam     &apos; JumpToNextFootnote  JumpToFootnoteOrAncho JumpToPrevFootnote

exit sub
konec:
   beep
end sub 




sub NactiIni
dim pom()
  if errControl then on error goto konec
  GlobalScope.BasicLibraries.LoadLibrary(inilib) &apos; natahnout knihovnu  
  
  pom = TmOption
  oDialog.Model.step = pom(0)  &apos;aktivni zalozka  
  oDialog.model.Cb_cz.state = pom(1) 
  oDialog.model.Tf_lib.text = pom(2)   
  oDialog.model.Cb_zoom.tag = pom(3)   

  redim makra()
  makra = MacroList
  exit sub
  
konec:
beep
end sub


&apos; v linuxu delala originální verze problémy, jednorozměrné pole povazovano za 2 rozmerne
&apos; zrušen volitelný parametr a nastaveno natvrdo
Function BubbleSortList_(ByVal SortList()) &apos;,optional sort2ndValue as Boolean)
&apos;This function bubble sorts an array of maximum 2 dimensions.
&apos;The default sorting order is the first dimension
&apos;Only if sort2ndValue is True the second dimension is the relevant for the sorting order
	Dim s as Integer
	Dim t as Integer
	Dim i as Integer
	Dim k as Integer
	Dim dimensions as Integer
	Dim sortvalue as Integer
	Dim DisplayDummy
	dimensions = 1
	
&apos;On Local Error Goto No2ndDim	
&apos;	k = Ubound(SortList(),2)
&apos;	No2ndDim:
&apos;	If Err &lt;&gt; 0 Then dimensions = 1
	
	i = Ubound(SortList(),1)
&apos;	If ismissing(sort2ndValue) then
		sortvalue = 0
&apos;	else
&apos;		sortvalue = 1
&apos;	end if
	
	For s = 1 to i - 1
		For t = 0 to i-s
			Select Case dimensions
			Case 1
				If SortList(t) &gt; SortList(t+1) Then                             
					DisplayDummy = SortList(t)
					SortList(t) = SortList(t+1)
					SortList(t+1) = DisplayDummy    
				End If
			Case 2
				If SortList(t,sortvalue) &gt; SortList(t+1,sortvalue) Then 
					For k = 0 to UBound(SortList(),2)                        
							DisplayDummy = SortList(t,k)
							SortList(t,k) = SortList(t+1,k)
							SortList(t+1,k) = DisplayDummy 
					Next k
				End If
			End Select
		Next t
	Next s 
	BubbleSortList_ = SortList()             
End Function





&apos; vraci pole jmen stylu
&apos; typ = ParagraphStyles, CharacterStyles, NumberingStyles
&apos; InUse vybere jen v textu použité styly
sub GetStyles(typ as string, InUse as boolean)as array  
dim oParst,i,n 
dim pom()
oParst =  AltSearchDoc.StyleFamilies.getbyname(typ)
n = 0
for i  = 0 to oParst.count-1
   if InUse then  &apos; jen použité
      if oParst.getByIndex(i).isInUse then
       redim preserve pom(n)
       pom(n) = oParst.getByIndex(i).DisplayName  &apos; lokalizovany nazev - česky
       n = n + 1
      end if 
     else  &apos; všechny
       redim preserve pom(n)
       pom(n) = oParst.getByIndex(i).DisplayName  &apos; lokalizovany nazev - česky
       n = n + 1
     end if  
      
 next i 
 GetStyles() = BubbleSortList_(pom())
end sub




&apos; pokud je změněn text hledaní a hledá se objekt tak, je nutno resetovat a aktualizovat tmppole()
&apos; přiřazeno události vstupní pole změněno
sub zmenaHledani(oEvt)

 if oDial.model.Ch_reg.state = 1 then
 
    if leftTo(oEvt.source.text,&quot;::]&quot;)&lt;&gt;&quot;&quot; then 
       CursorInit(true) &apos; nutno resetovat aby zohlednili případné změny
&apos;   msgbox &quot;zmena&quot;  
&apos;       prvniPruchod = true
       redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole
      end if 

  end if
end sub





&apos; nastavi znepristupnění pri zmene hledaní odst stylu
sub zmenaChstyle 
dim i
dim pom()
 if oDial.model.Ch_styl.state = 1 then &apos; deaktivovat vše kromě pozpatku a reg symbolu
     oDial.model.Ch_case.enabled =  false
     oDial.model.Ch_word.enabled =  false     
&apos;     oDial.model.Ch_reg.enabled =  false   
     oDial.model.Ch_reg.state =  1   
     oDial.model.Ch_preservecap.enabled =  false

&apos;     xray  oDial.getcontrol(&quot;Ch_findReg&quot;) &apos;.enabled 
     oDial.model.Cb_findReg.enabled =  false 
     oDial.model.Cb_findExt.enabled =  false 
     oDial.model.Cb_findAtr.enabled =  false 
     &apos; načíst do hledaní seznam použitých stylů    
     pom() = GetStyles(&quot;ParagraphStyles&quot;,true) &apos; pouzite odst. styly
     ulozHistorii &apos; uloži historii hledani a nahrad ze zaznamů do globálních polí
     oDial.getcontrol(&quot;Cb_find&quot;).removeItems(0,oDial.getcontrol(&quot;Cb_find&quot;).itemCount)  &apos; smazat predchozi     
     oDial.getcontrol(&quot;Cb_find&quot;).addItems(pom(),0)  &apos; pridat 
     oDial.model.Cb_find.text = pom(0)
     pom() = GetStyles(&quot;ParagraphStyles&quot;,false) &apos; vsechny odst. styly
     oDial.getcontrol(&quot;Cb_repl&quot;).removeItems(0,oDial.getcontrol(&quot;Cb_repl&quot;).itemCount)  &apos; smazat predchozi     
     for i = 0 to ubound(pom())
        pom(i) = &quot;\P{&quot; &amp; pom(i) &amp; &quot;}&quot;   
      next i
     oDial.getcontrol(&quot;Cb_repl&quot;).addItems(pom(),0)  &apos; pridat 
     oDial.model.Cb_repl.text = pom(0)
     
     
   else &apos;zpristupnit vse 
     oDial.model.Ch_case.enabled =  true
     oDial.model.Ch_word.enabled =  true     
&apos;     oDial.model.Ch_reg.enabled =  true 
     oDial.model.Ch_preservecap.enabled =  true 
    
     oDial.model.Cb_findReg.enabled =  true 
     oDial.model.Cb_findExt.enabled =  true 
     oDial.model.Cb_findAtr.enabled =  true 
     &apos; smazat seznam stylu pro hledani
     oDial.getcontrol(&quot;Cb_find&quot;).removeItems(0,oDial.getcontrol(&quot;Cb_find&quot;).itemCount)  &apos; smazat predchozi     
     oDial.getcontrol(&quot;Cb_find&quot;).addItems(AltSearchFind(),0)      &apos; nacist historii
     oDial.model.Cb_find.text = AltSearchFind(0)
     &apos; smazat seznam stylu pro nahrazeni
     oDial.getcontrol(&quot;Cb_repl&quot;).removeItems(0,oDial.getcontrol(&quot;Cb_repl&quot;).itemCount)  &apos; smazat predchozi     
     oDial.getcontrol(&quot;Cb_repl&quot;).addItems(AltSearchRepl(),0)      &apos; nacist historii
     oDial.model.Cb_repl.text = AltSearchRepl(0)


   end if
end sub




&apos; nastavi znepristupnění pri zmene Velka pismena
sub zmenaMachCase 
 if oDial.model.Ch_case.state = 1  then 
     oDial.model.Ch_preservecap.enabled =  false

   else &apos;zpristupnit
     oDial.model.Ch_preservecap.enabled =  true 
    
   end if
end sub


&apos; nastavi znepristupnění pri zmene Zachovni velkych pismen
sub zmenaPreserveCap 
 if oDial.model.Ch_preservecap.state = 1  then 
     oDial.model.Ch_case.enabled =  false
     
   else &apos;zpristupnit
     oDial.model.Ch_case.enabled =  true 
    
   end if
end sub





&apos; načte do prac. promenne volby hledani, aby se neprojevily případné změny v průběhu hledání
sub nactiVolby(obnov as boolean)
 if obnov then &apos; obnoví hodnoty z pole AltSearchIni - AltSearchVolby nefunguji globalne, asi bug
   AltSearchVolby.kcase = AltSearchIni(3) &apos; oDial.model.Ch_case.state &apos; case sensitive
   AltSearchVolby.word = AltSearchIni(4) &apos; oDial.model.Ch_word.state &apos; celá slova 
   AltSearchVolby.reg = AltSearchIni(5) &apos; oDial.model.Ch_reg.state  &apos; regularni vyrazy
   AltSearchVolby.zpet = AltSearchIni(6) &apos; oDial.model.Ch_zpet.state &apos; pozpatku
   AltSearchVolby.styl = AltSearchIni(7) &apos; oDial.model.Ch_styl.state &apos; hledat styly 
   AltSearchVolby.preservecap = AltSearchIni(10)  &apos; oDial.model.Ch_preservecap.state &apos; zachovat velká písmena   

   AltSearchVolby.find = AltSearchIni(8) 
   AltSearchVolby.repl = AltSearchIni(9)


   
   
  else  &apos; načíst podle nastavení dialogu
   AltSearchVolby.kcase = 0
   AltSearchVolby.word = 0
   AltSearchVolby.styl = 0
   AltSearchVolby.reg = 0
   AltSearchVolby.csele = 0
   AltSearchVolby.zpet = 0
   AltSearchVolby.preservecap = 0
   if (oDial.model.Ch_case.state = 1)and(oDial.model.Ch_case.enabled) then AltSearchVolby.kcase = 1
   if (oDial.model.Ch_word.state = 1)and(oDial.model.Ch_word.enabled) then AltSearchVolby.word = 1 
   if (oDial.model.Ch_styl.state = 1)and(oDial.model.Ch_styl.enabled) then AltSearchVolby.styl = 1
   if (oDial.model.Ch_reg.state = 1)and(oDial.model.Ch_reg.enabled) then AltSearchVolby.reg = 1
   if (oDial.model.Ch_preservecap.state = 1)and(oDial.model.Ch_preservecap.enabled) then AltSearchVolby.preservecap = 1

   if (oDial.model.Ch_csele.state = 1)and(oDial.model.Ch_csele.enabled) then AltSearchVolby.csele = 1
   if (oDial.model.Ch_zpet.state = 1)and(oDial.model.Ch_zpet.enabled) then AltSearchVolby.zpet = 1

   AltSearchVolby.find = oDial.model.Cb_find.text
   AltSearchVolby.repl = oDial.model.Cb_repl.text
   
   
  end if
end sub



&apos; znepristupní/zpristupní vsechny volby v pruběhu hledání, nahrazeni
sub HledamDisp(Off as boolean)
dim volba
&apos; if errControl then on error resume next
 volba = not off
 if not AltSearchDialog_end then
   with oDial.model
&apos;  .Ch_case.enabled = volba
&apos;  .Ch_word.enabled = volba
&apos;  .Ch_styl.enabled = volba
&apos;  .Ch_reg.enabled = volba
&apos;  .Ch_csele.enabled = volba
&apos;  .Ch_zpet.enabled = volba

&apos;  .Cb_find.enabled = volba
&apos;  .Cb_findReg.enabled = volba
&apos;  .Cb_findExt.enabled = volba
&apos;  .Cb_repl.enabled = volba
&apos;  .Cb_replExt.enabled = volba
  
   .Bt_count.enabled = volba
   .Bt_find.enabled = volba
   .Bt_findall.enabled = volba
   .Bt_repl.enabled = volba
   .Bt_replall.enabled = volba
   &apos; zalozka davky
   .Bt_run.enabled = volba   
  end with
 end if 


 if Off then
     StatusText(msg(7),100,true,AltSearchDoc.ParagraphCount) &apos;  vypis do stav. radku: &quot; (ESC pro přerušení) - Prohledano odstavců: &quot;
     findcounter = 0
     ncount = 0
     &apos;Vlastni obsluha pro možnost přerušení z dokumentu
     AltSearchKbd = createUnoListener(&quot;AltSearchKbd_&quot;,&quot;com.sun.star.awt.XKeyHandler&quot;)
     &apos; Priradeni obsluhy k aktuálnemu dokumentu
     AltSearchDocControl.addKeyHandler(AltSearchKbd)
     if not AltSearchDialog_end then
           oDial.model.Bt_close.label = msg(8) &apos; přerušit, jen pokud je otevren dialog
         end if  
   else  &apos; všechno ukončit
     StatusText(&quot;&quot;,100,true,0)   
     findcounter = -99
     if not AltSearchDialog_end then 
          oDial.model.Bt_close.label = msg(9) &apos; zavrit, jen pokud je otevren dialog
        end if  
     AltSearchDocControl.removeKeyHandler(AltSearchKbd)

   end if

end sub


sub evDialogKeypress(oEvt)
  beep
end sub



&apos; nastavi prCurs v zavislosti na vybranem bloku a volbe bloku
sub resetPrCurs
    &apos; nastavit zacatek hledani pokud se hleda jen uvnitr bloku pri prvnim hledani
    if (AltSearchVolby.csele = 1) then  
      if AltSearchVolby.zpet = 1 then   &apos; pro hledani od konce bloku
        prCurs = ovCurs.text.createTextCursorByRange(ovCurs.GetEnd()) &apos; pracovni podle viditelneho
       else   
        prCurs = ovCurs.text.createTextCursorByRange(ovCurs.GetStart()) &apos; pracovni podle viditelneho       
       end if
     else
      if AltSearchVolby.zpet = 1 then   &apos; pro hledani od konce dokumentu
        prCurs = AltSearchDoc.text.GetEnd()
       else   
        prCurs = AltSearchDoc.text.GetStart()
       end if
       
     end if 
end sub



&apos; vykonna procedura pro univerzalní pocitaní mimo spec objekty
&apos; mark povoli znaceni nalezenych textu pomoci BackgrounColor pro nasledny vyber vseho
sub Pocitej(hle(), mark as boolean)as boolean
   
    resetPrCurs &apos; nastavi prCurs v zavislosti na vybranem bloku a volbe bloku
     
    if not isSelTextRange(1) then goto konec  &apos; netextovy vyber by zpusobil chybu
 
    Pocitej = true
    AltSLastFound = FindNextInBlock(hle(), prCurs, AltSiniSel, true, mark) &apos; predhledat bez skupin
    if AltSLastFound = -999 then goto konec  &apos; přerušeno uzivatelem
&apos;    if findCounter &lt; 0 then goto konec  &apos; moznost přerušit počítaní
    exit sub
    
konec:
 Pocitej = false
end sub



&apos; vykonna procedura pro PROVEDENI VSECH ZAMEN pomoci hledej - nahrad
&apos; &quot;predhledani&quot; urcuje, zda se pouzije dvoustupnové hledani (nejdrive podle Hle(), pak podle hle1(),
&apos; pro urychleni pri hledani skupin
sub Zamenuj(predhledani as boolean )as boolean
dim Curs   
    resetPrCurs &apos; nastavi prCurs v zavislosti na vybranem bloku a volbe bloku
     
    if not isSelTextRange(1) then goto konec  &apos; netextovy vyber by zpusobil chybu
 
    Zamenuj = true
    
&apos;    predhledani = false
 
    AltSLastFound = FindNextInBlock(hle(), prCurs, AltSiniSel, false, false) &apos; predhledat bez skupin
    if (AltSLastFound = 0)and (AltSearchVolby.reg=1) and predhledani and not( (ubound(hle1())=0) and ((hle1(0).hled=&quot;$&quot;) or (hle1(0).atr=4) ) ) then  &apos;bez skupin bylo nalezeno - znovu prohledat se skupinami, jen pri regularnich symbolech a ne při hledaní samotneho $ a ne při hledani znakoveho stylu
        Curs = prCurs.text.createTextCursorByRange(prCurs) &apos; pomocny podle pracovniho kurzoru
        if AltSearchVolby.zpet = 1 then
            Curs.collapseToEnd
            &apos; když je kurzor na zacatku odstavce, OOo hledaní pozpatku najde až další zacatek odstavce - takže pokud se hledá začátek odstavce tak to přeskakuje  
&apos;            if curs.isStartOfParagraph and hle1(0).hled=&quot;$&quot; then curs.goRight(1,false)  &apos; vratit o jedno zpět
          else
            Curs.collapseToStart
            &apos; když je kurzor na konci odstavce, OOo hledaní najde až další konec odstavce - takže pokud se hledá konec odstavce tak to přeskakuje  
&apos;            if curs.isEndOfParagraph and hle1(0).hled=&quot;$&quot; then curs.goLeft(1,false)  &apos; vratit o jedno zpět
          end if  
        AltSLastFound = FindNextInBlock(hle1(), Curs, AltSiniSel, false, false) &apos; hledat podle skupin
      end if


    do while AltSLastFound=0 
       foundCaseType = getCapitalType(prCurs) 
       ReplCount = ReplCount + 1 &apos; pocitadlo zamen
       ReplDo  &apos; zamenit nalezene
       
       AltSLastFound = FindNextInBlock(hle(), prCurs, AltSiniSel, false, false) &apos; predhledat bez skupin
       if (AltSLastFound = 0)and (AltSearchVolby.reg=1) and predhledani and not( (ubound(hle1())=0) and ((hle1(0).hled=&quot;$&quot;) or (hle1(0).atr=4) ) ) then  &apos;bez skupin bylo nalezeno - znovu prohledat se skupinami, jen pri regularnich symbolech a ne při hledaní samotneho $ a ne při hledani znakoveho stylu
           Curs = prCurs.text.createTextCursorByRange(prCurs) &apos; pomocny podle pracovniho kurzoru
           if AltSearchVolby.zpet = 1 then
               Curs.collapseToEnd
               &apos; když je kurzor na zacatku odstavce, OOo hledaní pozpatku najde až další zacatek odstavce - takže pokud se hledá začátek odstavce tak to přeskakuje  
&apos;               if curs.isStartOfParagraph and hle1(0).hled=&quot;$&quot; then curs.goRight(1,false)  &apos; vratit o jedno zpět
             else
               Curs.collapseToStart
               &apos; když je kurzor na konci odstavce, OOo hledaní najde až další konec odstavce - takže pokud se hledá konec odstavce tak to přeskakuje  
&apos;               if curs.isEndOfParagraph and hle1(0).hled=&quot;$&quot; then curs.goLeft(1,false)  &apos; vratit o jedno zpět
             end if  

           AltSLastFound = FindNextInBlock(hle1(), Curs, AltSiniSel, false, false) &apos; hledat podle skupin
         end if

 &apos;       StatusInfo(17) &apos; Vypise po urcitem intervalu statusinfo
       if AltSLastFound = -999 then goto konec  &apos; přerušeno uzivatelem
       if findCounter &lt; 0 then goto konec 

      loop

    exit sub
    
konec:
 Zamenuj = false
end sub





sub addToHistory(hl as byte,na as byte) &apos; hledany, nahrazovany vyraz pridat do historie

  if hl = 1 then &apos;  
    &apos;pridat do seznamu historie hledani
     pridejDoSeznamuA(oDial.getcontrol(&quot;Cb_find&quot;), AltSearchVolby.find, 30, 0) &apos; max. 30 položek 
    &apos; ulozit pro dalsi spusteni
     AltSearchFind = oDial.getcontrol(&quot;Cb_find&quot;).getItems
   end  if 

 if na = 1 then &apos; 
   &apos;pridat do seznamu historie nahrazeni
   pridejDoSeznamuA(oDial.getcontrol(&quot;Cb_repl&quot;), AltSearchVolby.repl, 30, 0)  &apos; max. 30 položek
   &apos; ulozit pro dalsi spusteni
   AltSearchRepl = oDial.getcontrol(&quot;Cb_repl&quot;).getItems
  end  if 

end sub





&apos; spočítá výskyty
sub BtCount
dim info, curinit, curs, i, j, max, hled, pom, bin, oTmp, oAnch, inFoot, oFoot, mode
  
  info = &quot;&quot;  &apos; informacni pole pod hledej
  nactiVolby(false) &apos; ulozi volby hledani

  redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole

  addToHistory(1,0) &apos; hledany, nahrazovany vyraz pridat do historie

  i = instr(AltSearchVolby.find,&quot;[::BigBlock::]&quot;)
  if (i &gt; 0)and (AltSearchVolby.reg=1) then
    &apos; velky blok 
      &apos; zacatecni, otevírací retezec pro hledani bigbloku
      pom = left(AltSearchVolby.find,i-1) 
      hle1() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      &apos; konecny, zaviraci retezec pro hledani bigbloku
      pom = right(AltSearchVolby.find,len(AltSearchVolby.find)-i-13) &apos; hledam konec
      hle2() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      hle() = hle1()
      hle(0).cmd = &quot;[::BigBlock::]&quot;
    else 
    &apos; normalni hledani - ne velky blok
       pom = AltSearchVolby.find  
        if (AltSearchVolby.reg=1) then  &apos; připravit pro regexp
&apos;         pom = replace_(pom,&quot;\\&quot;,&quot;\&quot;)  &apos; nektere spec. znaky zamenit za hexa kody \x005C
         pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; neni to oddelovac OR ale znak &quot;|&quot;        
        end if 
       hle() = getFindArray(pom, false) &apos; pro predhledani, BEZ pripadnych skupin - prime hledani se skupinami je velmi pomale
       i = instr(pom,&quot;||&quot;)
       if (i &gt; 0)and (AltSearchVolby.reg=1) then &apos; nekolikanasobne nahrazení
          &apos;pole pro jednotlivá vicenasobná hledani 
          AltSearchMFind() = ArrayOutOfString_(pom,&quot;||&quot;)
          hle(0).cmd = &quot;[::MultipleSearch::]&quot;
        end if

     end if

&apos;  dbgVypisFind(hle())          

  curinit = false  &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
  HledamDisp(true) &apos; nepristupne pri pocitani 
  findcounter = 1  &apos; obecne pocitadlo pro stavove udaje; &gt;0 umožni prerušení akce
  ncount = 0       &apos; pocitadlo nalezenych vyrazů

  if AltSearchVolby.reg &lt;&gt; 1 then 
   &apos; normalni hledani bez regularnich výrazů
    if not Pocitej(hle(),false) then goto chyba &apos; vykonna procedura pro univerzalní pocitaní mimo spec objekty
    goto konec &apos; vypis vysledku a konec

   else  
   &apos; hledani s regulárními vyrazy 
    select case hle(0).cmd   
      case &quot;[::MultipleSearch::]&quot;
        for i=0 to ubound(AltSearchMFind())  &apos; hledat pres vsechny hledani
          pom = AltSearchMFind(i)  
          hle() = getFindArray(pom, false) &apos; pro predhledani, BEZ pripadnych skupin - prime hledani se skupinami je velmi pomale
          if not Pocitej(hle(),false) then goto chyba &apos; vykonna procedura pro univerzalní pocitaní mimo spec objekty
         next i
     

      case &quot;[::Note::]&quot;, &quot;[::Field::]&quot;, &quot;[::Reference::]&quot;
        hled = hle(0).hled
        select case hle(0).cmd
          case &quot;[::Note::]&quot;
           getSortFields(tmppole(), tmppole1(), &quot;Annotation&quot;, false)  &apos; rychle načíst netříděná poznamky
           if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; nastavit mod hledani
          case &quot;[::Field::]&quot;
           getSortFields(tmppole(), tmppole1(), &quot;All&quot;, false)  &apos; rychle načíst netříděná pole
           if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; nastavit mod hledani
          case &quot;[::Reference::]&quot;
           getSortFields(tmppole(), tmppole1(), &quot;GetReference&quot;, false)  &apos; rychle načíst netříděná reference
           mode = -1  &apos; -1 = hledání v textu co je vidět (kotvě objektu); 1 = hledat v Názvu (v bublině); 0 = hledat všechno
           if hled = &quot;\\&quot; then &apos; hledat prázdný text
               hled = &quot;&quot;
             else
               if left(hled,2)= &quot;\\&quot; then  &apos; hledat v názvu
                 mode = 1
                 hled = rightPast(hled, &quot;\\&quot;)
                else 
                 if hled = &quot;&quot; then  &apos; hledat všechno
                    mode = 0
                   end if
                end if
            end if

         end select 

        if (AltSearchVolby.csele=0) and (hled = &quot;&quot;) and (mode=0) then &apos; cely dokument
           &apos; zrychlení pro všechna pole v dokumentu
           ncount = ubound(tmppole()) + 1
          else
           for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů rámců
              select case hle(0).cmd
               case &quot;[::Note::]&quot;
                 pom = tmppole(i).content
               case &quot;[::Field::]&quot;
                 pom = tmppole(i).anchor.string
               case &quot;[::Reference::]&quot;
                 if mode = 1 then  &apos; hledat v názvu znacky ?
                     pom = tmppole(i).SourceName
                   else &apos; hledat v textu kotvy
                     pom = tmppole(i).anchor.string
                   end if
                end select 

              &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
              &apos; pokud je pom = 0  tak se hledá bez ohledu výskyt hled. podřetězce
              if isSubstrInBlock(tmppole(i),pom,hled,mode) then
                  ncount = ncount + 1 &apos; ano, nalezeno, zapocitat
                end if &apos; nalezen podretezec

              if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
            next i
          
           nastavVKurzor(AltSiniSel, false, &quot;&quot; ) &apos; obnovit původni vyber 
         
          end if



      case &quot;[::Footnote::]&quot;, &quot;[::Endnote::]&quot;
        hled = hle(0).hled
        &apos; \ = hledání v textu poznámky 
        inFoot = -1  &apos; -1 = hledání v kotvě co je vidět (kotvě objektu); 1 = hledat v textu poznamky (bublině); 0 = hledat všechno
        if left(hled,2)= &quot;\\&quot; then  
          inFoot = 1
          hled = rightPast(hled, &quot;\\&quot;)
         end if
        if hled = &quot;&quot; then inFoot = 0 &apos; hledat všechny
 
        if hle(0).cmd = &quot;[::Footnote::]&quot; then
           oFoot = AltSearchDoc.Footnotes
          else
           oFoot = AltSearchDoc.Endnotes
          end if 

        max = oFoot.count - 1  &apos; max index poslední poznamky
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        if (AltSearchVolby.csele=0) and (hled = &quot;&quot;) then &apos; vsechno v celem dokumentu
           &apos; zrychlení pro všechna pole v dokumentu
           ncount = max + 1
           goto konec
          end if

        for i = 0 to max
           &apos; hledat v obsahu poznamky ? 
           if inFoot=1 then  
               pom = oFoot(i).string
             else &apos; hledat v textu kotvy
               pom = oFoot(i).anchor.string
             end if

           &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
           &apos; pokud je inFoot = 0  tak se hledá bez ohledu výskyt hled. podřetězce
           if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
               ncount = ncount + 1
             end if &apos;nalezeno


           if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
           StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
          next i

&apos; debug info             
&apos;msgbox &quot;Index: &quot; &amp; i &amp; &quot;   ReferenceID: &quot; &amp; oFoot(i).ReferenceId &amp; &quot;   Anchor: &quot; &amp; oFoot(i).anchor.string &amp; &quot;   Label: &apos;&quot; &amp; oFoot(i).label &amp; chr(10) &amp; chr(10) &amp; oFoot(i).string



     case &quot;[::Bookmark::]&quot;
        hled = hle(0).hled
        &apos; \ = hledání ve jemenech založek 
        inFoot = -1  &apos; -1 = hledání v textu zalozky; 1 = hledat ve jmenech založek; 0 = hledat jakoukoli založku
        if left(hled,2)= &quot;\\&quot; then  
           inFoot = 1
           hled = rightPast(hled, &quot;\\&quot;)
          end if
        if hled = &quot;&quot; then inFoot = 0 &apos; hledat všechny   

        oFoot = AltSearchDoc.Bookmarks
        max = oFoot.count - 1  &apos; max index poslední poznamky
        if (AltSearchVolby.csele=0)and (hled = &quot;&quot;) and (inFoot=0) then &apos; vsechno v celem dokumentu
           &apos; zrychlení pro všechna pole v dokumentu
           ncount = max + 1
           goto konec
          end if

        for i = 0 to max
           &apos; hledat v obsahu zalozek ? 
           if inFoot=1 then  &apos; hledat ve jmenech
              pom = oFoot(i).Name   
            else &apos; hledat v textu kotvy
              pom = oFoot(i).anchor.string  &apos; hledat v obsahu textu zalozky
            end if

           &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
           &apos; pokud je inFoot = 0  tak se hledá bez ohledu výskyt hled. podřetězce
           if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
                 ncount = ncount + 1  &apos; označit a započítat  
                end if &apos; nalezene obarvit
 
           if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
           StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
          next i



      case &quot;[::ReferenceMark::]&quot;
        hled = hle(0).hled
        inFoot = -1  &apos; -1 = hledání v textu co je vidět (kotvě objektu); 1 = hledat ve Názvu (v bublině); 0 = hledat všechno
        if hled = &quot;\\\\&quot; then &apos; hledat prázdný text
            hled = &quot;&quot;
          else
            if left(hled,2)= &quot;\\&quot; then  &apos; hledat v názvu
              inFoot = 1
              hled = rightPast(hled, &quot;\\&quot;)
             else 
              if hled = &quot;&quot; then  &apos; hledat všechno
                 inFoot = 0
                end if
             end if
          end if
          
        oFoot = AltSearchDoc.ReferenceMarks
        max = oFoot.count - 1  &apos; max index poslední poznamky
        if (AltSearchVolby.csele=0)and (hled = &quot;&quot;) and (inFoot=0) then &apos; vsechno v celem dokumentu
           &apos; zrychlení pro všechna pole v dokumentu
           ncount = max + 1
           goto konec
          end if

        for i = 0 to max
           &apos; hledat v názvu znacky ? 
           if inFoot = 1 then  
               pom = oFoot(i).Name
             else &apos; hledat v textu kotvy
               pom = oFoot(i).anchor.string
             end if
             
           &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
           &apos; pokud je inFoot = 0  tak se hledá bez ohledu výskyt hled. podřetězce
           if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
                 ncount = ncount + 1  &apos; označit a započítat  
                end if &apos; nalezene obarvit
 
           if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
           StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
          next i



        

      case &quot;[::TextFrame::]&quot;
        max = getIndexTextFrame(1,0,&quot;&quot;)
        hled = hle(0).hled
        
        if AltSearchVolby.csele=0 then &apos; cely dokument
          if hled = &quot;&quot; then
            ncount = max + 1
           else
            &apos; spocitat jen ty co obsahuji hledany podretezec
            i = getIndexTextFrame(2,-1,hled)  &apos; najít 1. podretezec
            do while (i&gt;=0)and(i&lt;=max)
              ncount = ncount + 1
              i = getIndexTextFrame(2,i,hled)  &apos; najít dalsi podretezec

              if findcounter &lt; 0 then exit do &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
             loop    

           end if 
          
          else &apos; jen vyber
           &apos; pomocné pole s názvy textových rámců
           tmppole()= AltSearchDoc.getTextFrames.ElementNames
           if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

           for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů rámců
              &apos; nalezen podretezec nebo hledat vsechno
              if (instr(1,tmppole(i),hled,bin)&gt;0)or(hled=&quot;&quot;) then  
                &apos;zjistit kotvu - do oAnch
                oTmp = AltSearchDoc.getTextFrames.getByName(tmppole(i)) &apos; objekt ramce
                oAnch = getAnchorOfFramePicture(oTmp)
                &apos; je kotva uvnitř vyberu?
                if isInsideOfSelection(oAnch) then ncount = ncount + 1 &apos; ano, nalezeno, zapocitat

               end if &apos; nalezen podretezec nebo hledat vsechno

              if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
            next i
          
           nastavVKurzor(AltSiniSel, false, &quot;&quot; ) &apos; obnovit původni vyber 
          
          end if &apos; jen vyber



      case &quot;[::TextTable::]&quot;
        max = getIndexTextTable(1,0,&quot;&quot;)
        hled = hle(0).hled
        if AltSearchVolby.csele=0 then &apos; cely dokument
          if hled = &quot;&quot; then
             ncount = max + 1
            else
             &apos; spocitat jen ty co obsahuji hledany podretezec
             i = getIndexTextTable(2,-1,hled)  &apos; najít 1. podretezec
             do while (i&gt;=0)and(i&lt;=max)
               ncount = ncount + 1
               i = getIndexTextTable(2,i,hled)  &apos; najít dalsi podretezec

               if findcounter &lt; 0 then exit do &apos; prerusit ukoncit
               StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
              loop    

            end if 

         else &apos; jen vyber
           tmppole()= AltSearchDoc.getTextTables.ElementNames
           if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

           for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů tabulek
              &apos; nalezen podretezec nebo hledat vsechno
              if (instr(1,tmppole(i),hled,bin)&gt;0)or(hled=&quot;&quot;) then  
                &apos;zjistit kotvu - do oAnch
                oTmp = AltSearchDoc.getTextTables.getByName(tmppole(i)) &apos; objekt ramce
                oAnch = getTextRangeOfTable(oTmp)
                &apos; je kotva uvnitř vyberu?
                if isInsideOfSelection(oAnch) then ncount = ncount + 1 &apos; ano, nalezeno, zapocitat

               end if &apos; nalezen podretezec nebo hledat vsechno
          
              if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
            next i
          
           nastavVKurzor(AltSiniSel, false, &quot;&quot; ) &apos; obnovit původni vyber 

         end if &apos; jen vyber


      case &quot;[::Picture::]&quot;
        max = getIndexPicture(1,0,&quot;&quot;)
        hled = hle(0).hled
        if AltSearchVolby.csele=0 then &apos; cely dokument
         if hled = &quot;&quot; then
            ncount = max + 1
           else
            &apos; spocitat jen ty co obsahuji hledany podretezec
            i = getIndexPicture(2,-1,hled)  &apos; najít 1. podretezec
            do while (i&gt;=0)and(i&lt;=max)
              ncount = ncount + 1
              i = getIndexPicture(2,i,hled)  &apos; najít dalsi podretezec

              if findcounter &lt; 0 then exit do &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
             loop    

           end if

        else &apos; jen vyber
           tmppole()= AltSearchDoc.GraphicObjects.ElementNames
           if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

           for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů obrazků
              &apos; nalezen podretezec nebo hledat vsechno
              if (instr(1,tmppole(i),hled,bin)&gt;0)or(hled=&quot;&quot;) then  
                &apos;zjistit kotvu - do oAnch
                oTmp = AltSearchDoc.GraphicObjects.getByName(tmppole(i)) &apos; objekt ramce
                oAnch = getAnchorOfFramePicture(oTmp)
                &apos; je kotva uvnitř vyberu?
                if isInsideOfSelection(oAnch) then ncount = ncount + 1 &apos; ano, nalezeno, zapocitat

               end if &apos; nalezen podretezec nebo hledat vsechno
          
              if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
            next i
          
           nastavVKurzor(AltSiniSel, false, &quot;&quot; ) &apos; obnovit původni vyber 

        end if &apos; jen vyber



      case &quot;[::BigBlock::]&quot;  &apos; bigBlock
            resetPrCurs &apos; nastavi prCurs v zavislosti na vybranem bloku a volbe bloku
           hledejdal:
            j = FindNextInBlock(hle1(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs
            fo1 = nastavKurzor(prCurs)  &apos; zapamatovat zacatek
            fo2 = fo1.text.createTextCursor()  &apos;nastavKurzor(prCurs)  &apos; stejny region pro fo2

            j = FindNextInBlock(hle2(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs &apos; nenalezeno
            fo3 = nastavKurzor(prCurs)  &apos; vysledek uložit do fo3
            
            if nastavRozsah(fo2, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then
               prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
               goto hledejdal 
              end if 
         
            if AltSearchVolby.zpet = 1 then  &apos; opacne meze pro zpetne hledani
               if nastavRozsah(prCurs, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              else
               if nastavRozsah(prCurs, fo1.getStart(),fo3.getEnd()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              end if  

            &apos; nalezeno
            ncount = ncount + 1 
            goto hledejDal
          vratcurs:
           goto konec
      
      case else   &apos; standardní regul. výraz
        &apos; normalni regularni vyrazy
        if not Pocitej(hle(),false) then goto chyba &apos; vykonna procedura pro univerzalní pocitaní mimo spec objekty

     end select 
   
   end if  &apos; hledani s regulárními vyrazy


konec:
  HledamDisp(false) &apos; pristupne hledani 
  hlaseni(5) &apos; pocet
  redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole
  exit sub
  
chyba:
  HledamDisp(false) &apos; pristupne hledani 
end sub




&apos; vyhledat další
sub BtFindNext
dim info, curs,i, pom

  &apos; problém v Linuxu - nechtená aktualizace kurzoru po prvním hledání objektů
  &apos; pokjud je z minula načtené tmppole a je nastaven neprázddný retězec AltSearchFindLast, tak se předpokládá že nejde o první pruchod 
  &apos; AltSearchFindLast se nastavi pri prvním načtení tmppole() v procedure mySelDialFocus()
  &apos; to vse je potřeba kvůlo nefunkčnosti oDial.setFocus() po schování okna a zobrazení okna souboru v Linuxu OOo minimálně do verze 2.2.1
  &apos; GetGuiType  &apos; 1=Win 2=Mac 3=UNIX 4=Linux
  &apos; oDial.model.Cb_find.text
  if ((GetGuiType=3)or(GetGuiType=4) )and(ubound(tmppole())&gt;-1)and(prvnipruchod)and(leftTo(AltSearchFindLast,&quot;::]&quot;)=leftTo(oDial.model.Cb_find.text,&quot;::]&quot;)) then prvnipruchod = false
  AltSearchFindLast = &quot;&quot;

  info = &quot;&quot;  &apos; informacni pole pod hledej
  nactiVolby(false) &apos; ulozi volby hledani

  if prvnipruchod then 
    redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole
    FoundBookmarkNo = -1 &apos; index nalezene založky při hledání [::Bookmark::]  
   end if


  if isSelTextRange(0) then  &apos; pouze pro textRange
   &apos; nastavit zacatek hledani pokud se hleda jen uvnitr bloku pri prvnim hledani
    if prvnipruchod and (AltSearchVolby.csele = 1) then  
      if AltSearchVolby.zpet = 1 then   &apos; pro hledani od konce bloku
        ovCurs.collapseToEnd
       else   
        ovCurs.collapseToStart  
       end if
&apos;      prvnipruchod=false
     end if 
    end if 

&apos;  if prvnipruchod then : beep : beep : beep : end if

  addToHistory(1,0) &apos; hledany, nahrazovany vyraz pridat do historie


  i = instr(AltSearchVolby.find,&quot;[::BigBlock::]&quot;)
  if (i &gt; 0)and (AltSearchVolby.reg=1) then
    &apos; velky blok 
      &apos; zacatecni, otevírací retezec pro hledani bigbloku
      pom = left(AltSearchVolby.find,i-1) 
      hle1() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      &apos; konecny, zaviraci retezec pro hledani bigbloku
      pom = right(AltSearchVolby.find,len(AltSearchVolby.find)-i-13) &apos; hledam konec
      hle2() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      hle() = hle1()
      hle(0).cmd = &quot;[::BigBlock::]&quot;
    else 
    &apos; normalni hledani - ne velky blok
       pom = AltSearchVolby.find  

       if (AltSearchVolby.reg=1) then  &apos; připravit pro regexp
&apos;         pom = replace_(pom,&quot;\\&quot;,&quot;\&quot;)  &apos; nektere spec. znaky zamenit za hexa kody \x005C
         pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; neni to oddelovac OR ale znak &quot;|&quot;        
        end if 
       i = instr(pom,&quot;||&quot;)
       if (i &gt; 0)and (AltSearchVolby.reg=1) then &apos; nekolikanasobne nahrazení
          pom = replace_(pom,&quot;||&quot;,&quot;|&quot;)  &apos; pro orientacni vyhledani pouze pomoci | OR
          hle1() = getFindArray(pom, false) &apos; bez skupin - nepredhledavat

        else
          hle1() = getFindArray(pom, true) &apos; pole s hledanim vcetne skupin () - pole ma vice zaznamu = pomalejsi hledani
        end if

       hle() = getFindArray(pom, false) &apos; pro predhledani, BEZ pripadnych skupin - prime hledani se skupinami je velmi pomale

     end if

&apos; dbgVypisFind(hle())
&apos; dbgVypisFind(hle1())
&apos; exit sub


  FindDo  &apos; vlastni vyhledani
  
  
  &apos; nepracuje spolehlive, přesněji pracuje jen málo kdy v závislosti na ???
  &apos; pokusný provoz
  PosunZakrytyText  &apos; pokud je kurzor schován pod oknem dialogu posune zobrazení (má-li kam) 
  
  
  if prvnipruchod then prvnipruchod = false

&apos; msgbox foundCaseType
&apos;  msgbox &quot;co ted?  &quot; &amp; AltSearchSkup(12)  
&apos;  msgbox  ubound(tmppole()) &amp; &quot; &quot; &amp; prvnipruchod  

end sub





&apos; vyhledat všechno
sub BtFindAll
dim info, curinit, curs, i, j, max, hled, pom, bin, oAnch, oFoot, inFoot, mode
  
  info = &quot;&quot;  &apos; informacni pole pod hledej
  nactiVolby(false) &apos; ulozi volby hledani

  redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole

  addToHistory(1,0) &apos; hledany, nahrazovany vyraz pridat do historie

  i = instr(AltSearchVolby.find,&quot;[::BigBlock::]&quot;)
  if (i &gt; 0)and (AltSearchVolby.reg=1) then
    &apos; velky blok 
      &apos; zacatecni, otevírací retezec pro hledani bigbloku
      pom = left(AltSearchVolby.find,i-1) 
      hle1() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      &apos; konecny, zaviraci retezec pro hledani bigbloku
      pom = right(AltSearchVolby.find,len(AltSearchVolby.find)-i-13) &apos; hledam konec
      hle2() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      hle() = hle1()
      hle(0).cmd = &quot;[::BigBlock::]&quot;
    else 
    &apos; normalni hledani - ne velky blok
       pom = AltSearchVolby.find 
       &apos;test nekolikanasobneho nahrazeni  
       if (AltSearchVolby.reg=1) then  &apos; připravit pro regexp
&apos;         pom = replace_(pom,&quot;\\&quot;,&quot;\&quot;)  &apos; nektere spec. znaky zamenit za hexa kody \x005C
         pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; neni to oddelovac OR ale znak &quot;|&quot;        
        end if 
       hle() = getFindArray(pom, false) &apos; pro predhledani, BEZ pripadnych skupin - prime hledani se skupinami je velmi pomale
       i = instr(pom,&quot;||&quot;)
       if (i &gt; 0)and (AltSearchVolby.reg=1) then &apos; nekolikanasobne nahrazení s reg symboly
          hle1() = getFindArray(pom, false) &apos; bez skupin, neni dulezite, stejne se budou jeste jednou nacitat jednotlive 
          &apos;pole pro jednotlivá vicenasobná hledani 
          hle(0).cmd = &quot;[::MultipleSearch::]&quot;  &apos; na zbytku nezalezi zpracuji se jeste jednou
          AltSearchMFind() = ArrayOutOfString_(pom,&quot;||&quot;)  &apos; Pole s jedotlivymi retezci pro hledani 

        else
          &apos; u find all se hle1() nepouzije?
          hle1() = getFindArray(pom, true) &apos; pole s hledanim vcetne skupin () - pole ma vice zaznamu = pomalejsi hledani
        end if

     end if

  curinit = false  &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
  HledamDisp(true) &apos; nepristupne pri pocitani 
  findcounter = 1  &apos; obecne pocitadlo pro stavove udaje; &gt;0 umožní přerušení
  ncount = 0       &apos; pocitadlo nalezenych vyrazů
  varovani = true  &apos; umozni zobrazit varovani pred moznosti poruseni zvyrazneni

  if AltSearchVolby.reg &lt;&gt; 1 then 
   &apos; normalni hledani bez regularnich výrazů
    if not Pocitej(hle(),true) then goto chyba &apos; vykonna procedura pro univerzalní pocitaní mimo spec objekty
    if isObject(foundAll) then &apos; bylo nalezeno zrychleným hledaním, je-li 0 tak zvyraznit pomoci Bcolor
 &apos;      xray foundAll.getbyindex(1)
      &apos; !!! todo bug OOo?: nevybere se 1. (index 0) kolekce 
       AltSearchDoc.getCurrentController.select(foundAll)  &apos;&apos;
       hlaseni(5)
       goto chyba &apos; konec bez zvyrazneni pomoci bcolor       
      end if      
    &apos; normální konec se zvyraznením pomoci bcolor 

   else  
   &apos; hledani s regulárními vyrazy 
    select case hle(0).cmd   
      case &quot;[::MultipleSearch::]&quot;
        for i=0 to ubound(AltSearchMFind())  &apos; hledat pres vsechny || hledani
          pom = AltSearchMFind(i)
          hle() = getFindArray(pom, false) &apos; pro predhledani, BEZ pripadnych skupin - prime hledani se skupinami je velmi pomale
          if not Pocitej(hle(),true) then goto chyba &apos; vykonna procedura pro univerzalní pocitaní mimo spec objekty
          if isObject(foundAll) then &apos; bylo nalezeno zrychleným hledaním ale stejne je nutno oznacit
             &apos; zobrazit varovani o poruseni zvyrazneni pred prvnim použitím
             if varovani then  &apos; jen poprve
               if isUsedCharBackColor then
                   if 6 &lt;&gt; hlaseni(7) then goto chyba
                 end if
               ClearBackColor &apos; zrusit pripadne predchozi pomocne barvy
               varovani = false
              end if

             for j = 0 to foundAll.count-1
               foundAll(j).CharBackColor = bcolor 
              next j
            end if      

         next i
     
      case &quot;[::Note::]&quot;, &quot;[::Field::]&quot;, &quot;[::Reference::]&quot;
        if isUsedCharBackColor then
          if 6 &lt;&gt; hlaseni(7) then goto chyba &apos; Varovani o zvýraznění 
         end if 
        ClearBackColor &apos; zrusit pripadne predchozi pomocne barvy

        hled = hle(0).hled
        select case hle(0).cmd
          case &quot;[::Note::]&quot;
           getSortFields(tmppole(), tmppole1(), &quot;Annotation&quot;, false)  &apos; rychle načíst netříděná poznamky
           if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; nastavit mod hledani
          case &quot;[::Field::]&quot;
           getSortFields(tmppole(), tmppole1(), &quot;All&quot;, false)  &apos; rychle načíst netříděná pole
           if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; nastavit mod hledani
          case &quot;[::Reference::]&quot;
           getSortFields(tmppole(), tmppole1(), &quot;GetReference&quot;, false)  &apos; rychle načíst netříděná reference
           mode = -1  &apos; -1 = hledání v textu co je vidět (kotvě objektu); 1 = hledat v Názvu (v bublině); 0 = hledat všechno
           if hled = &quot;\\&quot; then &apos; hledat prázdný text
               hled = &quot;&quot;
             else
               if left(hled,2)= &quot;\\&quot; then  &apos; hledat v názvu
                 mode = 1
                 hled = rightPast(hled, &quot;\\&quot;)
                else 
                 if hled = &quot;&quot; then  &apos; hledat všechno
                    mode = 0
                   end if
                end if
            end if

         end select 

        if (AltSearchVolby.csele=0) and (hled = &quot;&quot;) and (mode=0) then &apos; cely dokument
           &apos; zrychlení pro všechna pole v dokumentu
           for i = 0 to ubound(tmppole()) &apos; obarvit vsechno
               tmppole(i).anchor.CharBackColor = bcolor
               ncount = ncount + 1

               if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
               StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
             next i

          else
           for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů rámců
              select case hle(0).cmd
               case &quot;[::Note::]&quot;
                 pom = tmppole(i).content
               case &quot;[::Field::]&quot;
                 pom = tmppole(i).anchor.string
               case &quot;[::Reference::]&quot;
                 if mode = 1 then  &apos; hledat v názvu znacky ?
                     pom = tmppole(i).SourceName
                   else &apos; hledat v textu kotvy
                     pom = tmppole(i).anchor.string
                   end if
                end select 

              &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
              &apos; pokud je pom = 0  tak se hledá bez ohledu výskyt hled. podřetězce
              if isSubstrInBlock(tmppole(i),pom,hled,mode) then
                  tmppole(i).anchor.CharBackColor = bcolor
                  ncount = ncount + 1 &apos; ano, nalezeno, zapocitat
                end if &apos; nalezen podretezec

              if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
            next i
          
           nastavVKurzor(AltSiniSel, false, &quot;&quot; ) &apos; obnovit původni vyber 
         
          end if

    
      case &quot;[::Footnote::]&quot;, &quot;[::Endnote::]&quot;
        if isUsedCharBackColor then
          if 6 &lt;&gt; hlaseni(7) then goto chyba &apos; Varovani o zvýraznění 
         end if 
        ClearBackColor &apos; zrusit pripadne predchozi pomocne barvy

        hled = hle(0).hled

        &apos; \ = hledání v textu poznámky 
        inFoot = -1  &apos; -1 = hledání v kotvě co je vidět (kotvě objektu); 1 = hledat v textu poznamky (bublině); 0 = hledat všechno
        if left(hled,2)= &quot;\\&quot; then  
          inFoot = 1
          hled = rightPast(hled, &quot;\\&quot;)
         end if
        if (hled = &quot;&quot;) then inFoot = 0 &apos; hledat všechny

        if hle(0).cmd = &quot;[::Footnote::]&quot; then
            oFoot = AltSearchDoc.Footnotes
           else
            oFoot = AltSearchDoc.Endnotes
           end if 

        max = oFoot.count - 1  &apos; max index poslední poznamky
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        for i = 0 to max
           &apos; hledat v obsahu poznamky ? 
           if inFoot=1 then  
               pom = oFoot(i).string
             else &apos; hledat v textu kotvy
               pom = oFoot(i).anchor.string
             end if
             
           &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
           &apos; pokud je inFoot = 0  tak se hledá bez ohledu výskyt hled. podřetězce
           if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
                &apos; označit a započítat  
                if left(hle(0).hled,2)= &quot;\\&quot; then &apos; výjimka: na zacatku bylo \ tj. vybrat texty poznámek
                  &apos; pomocný kurzor s textem poznamky
                  curs = oFoot(i).start.text.createTextCursorByRange(oFoot(i).start.getStart())
                  curs.goToRange(oFoot(i).getEnd(),true)
                  curs.CharBackColor = bcolor
                 else  &apos; vybrat kotvy
                  oFoot(i).anchor.CharBackColor = bcolor
                 end if 
                ncount = ncount + 1

             end if &apos;nalezeno

           if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
           StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo

          next i


      case &quot;[::ReferenceMark::]&quot;
        if isUsedCharBackColor then
          if 6 &lt;&gt; hlaseni(7) then goto chyba &apos; Varovani o zvýraznění 
         end if 
        ClearBackColor &apos; zrusit pripadne predchozi pomocne barvy

        hled = hle(0).hled
        inFoot = -1  &apos; -1 = hledání v textu co je vidět (kotvě objektu); 1 = hledat ve Názvu (v bublině); 0 = hledat všechno
        if hled = &quot;\\\\&quot; then &apos; hledat prázdný text
            hled = &quot;&quot;
          else
            if left(hled,2)= &quot;\\&quot; then  &apos; hledat v názvu
              inFoot = 1
              hled = rightPast(hled, &quot;\\&quot;)
             else 
              if hled = &quot;&quot; then  &apos; hledat všechno
                 inFoot = 0
                end if
             end if
          end if
          
        oFoot = AltSearchDoc.ReferenceMarks
        max = oFoot.count - 1  &apos; max index poslední poznamky
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        for i = 0 to max
           &apos; hledat ve nazvu značky 
           if inFoot = 1 then  
               pom = oFoot(i).Name
             else &apos; hledat v textu 
               pom = oFoot(i).anchor.string
             end if

           &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
           &apos; pokud je inFoot = 0  tak se hledá bez ohledu výskyt hled. podřetězce
           if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
                 &apos; označit a započítat  
                 if oFoot(i).anchor.string = &quot;&quot; then
                   curs = oFoot(i).anchor.text.createTextCursorByRange(oFoot(i).anchor.getStart())
                   curs.goRight(1,true)
                   curs.CharBackColor = bcolor
                  else
                   oFoot(i).anchor.CharBackColor = bcolor
                  end if 

                 ncount = ncount + 1

             end if &apos; nalezeno

             if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
             StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
           next i


      case &quot;[::Bookmark::]&quot;
        hlaseni(6)
        goto chyba

      case &quot;[::TextFrame::]&quot;
        hlaseni(6)
        goto chyba

      case &quot;[::TextTable::]&quot;
        hlaseni(6)
        goto chyba

      case &quot;[::Picture::]&quot;
        hlaseni(6)
        goto chyba

      case &quot;[::BigBlock::]&quot;  &apos; bigBlock
            resetPrCurs &apos; nastavi prCurs v zavislosti na vybranem bloku a volbe bloku
           hledejdal:
            j = FindNextInBlock(hle1(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs
            fo1 = nastavKurzor(prCurs)  &apos; zapamatovat zacatek
            fo2 = fo1.text.createTextCursor()  &apos;nastavKurzor(prCurs)  &apos; stejny region pro fo2

            j = FindNextInBlock(hle2(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs &apos; nenalezeno
            fo3 = nastavKurzor(prCurs)  &apos; vysledek uložit do fo3
            
            if nastavRozsah(fo2, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then
               prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
               goto hledejdal 
              end if 
         
            if AltSearchVolby.zpet = 1 then  &apos; opacne meze pro zpetne hledani
               if nastavRozsah(prCurs, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              else
               if nastavRozsah(prCurs, fo1.getStart(),fo3.getEnd()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              end if  

            &apos; nalezeno
            &apos; zobrazit varovani o poruseni zvyrazneni pred prvnim použitím
             if varovani then  &apos; jen poprve
               if isUsedCharBackColor then
                   if 6 &lt;&gt; hlaseni(7) then goto chyba
                 end if
               ClearBackColor &apos; zrusit pripadne predchozi pomocne barvy
               varovani = false
              end if
             prCurs.CharBackColor = bcolor  &apos; je-li zapnuto značení tak označit barvou

            &apos; nalezeno
            ncount = ncount + 1 
            goto hledejDal

          vratcurs:
           goto konec
      
      case else   &apos; standardní regul. výraz
        &apos; normalni regularni vyrazy
        if not Pocitej(hle(),true) then goto chyba &apos; vykonna procedura pro univerzalní pocitaní mimo spec objekty
        if isObject(foundAll) then &apos; bylo nalezeno zrychleným hledaním
           AltSearchDoc.getCurrentController.select(foundAll)
           ncount = foundAll.count  
           goto konec1 &apos; konec bez zvyrazneni pomoci bcolor       
          end if      
        &apos; normální konec se zvyraznením pomoci bcolor 

     end select 
   
   end if  &apos; hledani s regulárními vyrazy


konec:
   SelectAllBColor &apos; vybere jako nesouvisly blok vsechno co má pozadí &quot;bColor&quot;
   ClearBackColor  &apos; zrusit pomocne barvy        
konec1:
   HledamDisp(false) &apos; pristupne hledani   
   hlaseni(5) &apos; BtFindAll 
   redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole
  exit sub

  
chyba:
  HledamDisp(false) &apos; pristupne hledani 
end sub





sub BtReplace
dim pom, i

&apos;on error goto next

 &apos; pro linux hledaní žlutých poznammek jinak zmatky při prvním nahrazení
 If oSels.supportsService(&quot;com.sun.star.text.TextRanges&quot;) Then prCurs = ovCurs.text.createTextCursorByRange(ovCurs) &apos; pracovni podle viditelneho


 &apos; je opravdu nalezen blok
 if AltSLastFound&lt;&gt;0 then goto najdiDalsi
 if AltSLastFound&lt;&gt;0 then exit sub  &apos; nenalezeno, konec

 nactiVolby(false) &apos; ulozi, aktualizuje volby hledani
 
 addToHistory(0,1) &apos; hledany, nahrazovany vyraz pridat do historie
 
  repl() = getReplArray(AltSearchVolby.repl) &apos; načíst pole nahrad

&apos; dbgVypisRepl(repl())
&apos; exit sub

  fo1s = &quot;&quot; :  fo2s = &quot;&quot; : fo3s = &quot;&quot;  &apos; reset retezcu bigbloku

  errProp = 0 &apos; počitadlo neuspesnych nastaveni properties

  textFields = false  &apos; přiznak pro aktualizaci polí 
  HledamDisp(true) &apos; nepristupna tlacitka a hledani 
  ReplDo  &apos; provede nahrady, prCurs je na konci nebo začátku podle smeru
  HledamDisp(false) &apos; pristupna tlacitka a hledani 

  if textFields then update_fields  &apos; je-li potřeba aktualizovat pole &apos; aktualizuje hodnoty textových polí v dokumentu aby po vložení ukazovali správné hodnoty
  redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole

  BatReplCount  = BatReplCount + 1  &apos; počitadlo zamen davkoveho zpracovani
 
  if errProp &gt; 0 then  hlaseni1(16, true, false, msg(23) &amp; errProp &amp; msg(15)) &apos; Počet neúspěšně nastavených vlastností: &apos; styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti

  
najdiDalsi:
  BtFindNext
end sub






sub BtReplaceAll
dim info, curinit, curs, rest, n, i, j, max, hled, pom, oTmp, oAnch, bin, inFoot, oFoot, mode
  
  bin = 0  &apos; urcuje druh hledani velkych pismen v podretezcich
  info = &quot;&quot;  &apos; informacni pole pod hledej
  nactiVolby(false) &apos; ulozi volby hledani
  textFields = false &apos; pro aktualizaci polí
  fo1s = &quot;&quot; :  fo2s = &quot;&quot; : fo3s = &quot;&quot;  &apos; reset retezcu bigbloku
  
  redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole
 
  addToHistory(1,1) &apos; hledany, nahrazovany vyraz pridat do historie

  i = instr(AltSearchVolby.find,&quot;[::BigBlock::]&quot;)
  if (i &gt; 0)and (AltSearchVolby.reg=1) then
    &apos; velky blok 
      &apos; zacatecni, otevírací retezec pro hledani bigbloku
      pom = left(AltSearchVolby.find,i-1) 
      hle1() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      &apos; konecny, zaviraci retezec pro hledani bigbloku
      pom = right(AltSearchVolby.find,len(AltSearchVolby.find)-i-13) &apos; hledam konec
      hle2() = getFindArray(pom, false) &apos; pole s hledanim bez skupin ()
      hle() = hle1()
      hle(0).cmd = &quot;[::BigBlock::]&quot;
    else 
    &apos; normalni hledani - ne velky blok
       &apos;test nekolikanasobneho nahrazeni  
       pom = AltSearchVolby.find 
       if (AltSearchVolby.reg=1) then  &apos; připravit pro regexp
&apos;         pom = replace_(pom,&quot;\\&quot;,&quot;\&quot;)  &apos; nektere spec. znaky zamenit za hexa kody \x005C
         pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; neni to oddelovac OR ale znak &quot;|&quot;        
        end if 

       hle() = getFindArray(pom, false) &apos; pro predhledani, BEZ pripadnych skupin - prime hledani se skupinami je velmi pomale
       i = instr(pom,&quot;||&quot;)
       if (i &gt; 0)and (AltSearchVolby.reg=1) then &apos; nekolikanasobne nahrazení s reg symboly
          hle1() = getFindArray(pom, false) &apos; bez skupin, neni dulezite, stejne se budou jeste jednou nacitat jednotlive 
          &apos;pole pro jednotlivá vicenasobná hledani 
          hle(0).cmd = &quot;[::MultipleSearch::]&quot;  &apos; na zbytku nezalezi zpracuji se jeste jednou
          AltSearchMFind() = ArrayOutOfString_(pom,&quot;||&quot;)  &apos; Pole s jedotlivymi retezci pro hledani 
          &apos; uprava nahrazovaciho retezce
          pom = replace_(AltSearchVolby.repl,&quot;\\&quot;,&quot;\x005C&quot;)  &apos; spec. znaky zamenit za hexa kody
          pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)                 &apos; neni to oddelovac OR ale znak &quot;|&quot;
          AltSearchMRepl() = ArrayOutOfString_(pom,&quot;||&quot;)  &apos; Pole s jedotlivymi retezci pro nahrazeni 
        else
          &apos; u find all se hle1() nepouzije?
          hle1() = getFindArray(pom, true) &apos; pole s hledanim vcetne skupin () - pole ma vice zaznamu = pomalejsi hledani
        end if

     end if
 
  repl() = getReplArray(AltSearchVolby.repl) &apos; načíst pole nahrad

 &apos; dbgVypisFind(hle())
&apos; dbgVypisRepl(repl())
&apos; exit sub 

  curinit = false  &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
  HledamDisp(true) &apos; nepristupne pri pocitani 
  errProp = 0 &apos; počitadlo neuspesnych nastaveni properties
  findcounter = 1  &apos; obecne pocitadlo pro stavove udaje &gt;0 umožní přerušení
  ReplCount = 0    &apos; pocitadlo nalezenych zamen
  nCount = 0 

  if AltSearchVolby.reg &lt;&gt; 1 then 
   &apos; normalni hledani bez regularnich výrazů, false - bez predhledani, nei terba, nejsou reg. vyrazy
    if not Zamenuj(false) then goto chyba &apos; vykonna procedura pro PROVEDENI VSECH ZAMEN pomoci hledej - nahrad

    goto konec &apos; vypis vysledku a konec

   else  
   &apos; hledani s regulárními vyrazy 
    select case hle(0).cmd   
      case &quot;[::MultipleSearch::]&quot;
        for i=0 to ubound(AltSearchMFind())  &apos; hledat pres vsechny hledani
          hle() = getFindArray(AltSearchMFind(i), false) &apos; pro predhledani, BEZ pripadnych skupin - prime hledani se skupinami je velmi pomale
          hle1() = getFindArray(AltSearchMFind(i), true) &apos; pro predhledani, včetně skupin                       
          if ubound(AltSearchMRepl()) &gt;= i then
            repl() = getReplArray(AltSearchMRepl(i)) &apos; načíst pole nahrad
            if not Zamenuj(false) then goto chyba &apos; vykonna procedura pro PROVEDENI VSECH ZAMEN pomoci hledej - nahrad
           end if 
         
         next i
     
      case &quot;[::Note::]&quot;
        max = getIndexNote(1,0,&quot;&quot;)
        hled = hle(0).hled
        &apos; pomocné pole tmppole() s názvy textových rámců je načteno z getIndexNote()
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty  
           &apos; nalezen podretezec nebo hledat vsechno
            if (instr(1,tmppole(i).content,hled,bin)&gt;0)or(hled=&quot;&quot;) then  
              &apos;zjistit kotvu - do oAnch
              oAnch = tmppole(i).anchor &apos; nalezeny objekt
              &apos; je kotva uvnitř vyberu?
              if isInsideOfSelection(oAnch) then  &apos; ano, nalezeno, zamenit
                  prCurs = tmppole(i).anchor &apos; nalezeny objekt
                  info = tmppole(i).content  &apos; informacni pole pod hledej
                  curinit = false &apos; po nalezeni obcerstvit kurzory - pozor asi zrusi IniBlok pro hledani v bloku!!
                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = info  &apos; textový obsah poznamky
                  pom = tmppole(i).SupportedServiceNames(0)
                  AltSearchSkup(12) = right(pom,len(pom)-18)  &apos; uno nazev poznamky                        
                  
                  nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                  
                  nastavVKurzor(prCurs, curinit, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny
                
                end if

             end if &apos; nalezen podretezec nebo hledat vsechno
          
            if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
            StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
           next i
  
  
  
  
     case &quot;[::Bookmark::]&quot;
        hled = hle(0).hled

        &apos; \ = hledání ve jemenech založek 
        mode = -1  &apos; -1 = hledání v textu zalozky; 1 = hledat ve jmenech založek; 0 = hledat jakoukoli založku
        if left(hled,2)= &quot;\\&quot; then  
          mode = 1
          hled = rightPast(hled, &quot;\\&quot;)
         end if
        if hled = &quot;&quot; then mode = 0 &apos; hledat všechny         
         
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 
          
        tmppole = AltSearchDoc.Bookmarks
        max = tmppole.count - 1  &apos; max index poslední poznamky

&apos;        for i = max to 0 step -1  &apos; pro vsechny objekty  
        do while (i &lt;= tmppole.count - 1)  &apos; index poslední poznamky při smazani založky se zmeni pocet indexů
           &apos; hledat v obsahu zalozek ? 
            if mode=1 then  &apos; hledat ve jmenech
              pom = tmppole(i).Name   
             else &apos; hledat v textu kotvy
              pom = tmppole(i).anchor.string  &apos; hledat v obsahu textu zalozky
             end if
             
           &apos; nalezen podretezec nebo hledat vsechno
            if (instr(1,pom,hled,bin)&gt;0)or(hled=&quot;&quot;) then  
              &apos;zjistit kotvu - do oAnch
              oAnch = tmppole(i).anchor &apos; nalezeny objekt
              &apos; je kotva uvnitř vyberu?
              if isInsideOfSelection(oAnch) then  &apos; ano, nalezeno, zamenit
                  &apos; kotva anchor neni kurzor ale textRange =&gt; převest na kurzor, jinak chyby
                  FoundBookmarkNo = i  &apos; uložit index zpracovávané záložky 
                  prCurs = tmppole(i).anchor.text.createTextCursorByRange(tmppole(i).anchor) &apos; .getStart()
                  &apos;  prCurs = tmppole(i).anchor &apos; nalezeny objekt
                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = tmppole(i).anchor.String  &apos; text založky  pro repl \o
                  AltSearchSkup(12) = tmppole(i).getName()  &apos; nazev do replpar \O     
             
                  if mode = 1 then &apos; hledani ve jmenech zalozek
                    nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2); v \b je část před hledaným podret., v \e je část za hledaným hledaným podret. a v &amp; je hledaný retezec

                   else  &apos; hledani v textu založky
                    nastavSkupiny012(prCurs.String, hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezcem: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                   end if                   
             
                  nastavVKurzor(prCurs, false, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny
              
                end if

             end if &apos; nalezen podretezec nebo hledat vsechno
             
            &apos; if findcounter &lt; 0 then exit for &apos; prerusit, ukoncit
            if findcounter &lt; 0 then i = tmppole.count + 100  &apos; prerusit, ukoncit
            StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo

            i = i+1
            if (tmppole.count-1)&lt;max then &apos; soucasny počet zalozek je menší než původní - ReplDo nějaké smazal
               i = i - max + tmppole.count - 1              
               if i&lt;0 then i = tmppole.count + 10  &apos; pro jistotu; prerusit, ukoncit
               max = tmppole.count-1  &apos; aktualizovat maximum
             endif

            if (tmppole.count-1)&gt;max then &apos; soucasny počet zalozek je vetší než původní - ReplDo nějaké přidal
              &apos;dodelat todo
               i = i - max + tmppole.count - 1              
&apos;               if i&lt;0 then i = tmppole.count + 10  &apos; pro jistotu; prerusit, ukoncit
               max = tmppole.count-1  &apos; aktualizovat maximum
             end if
            
          loop
        &apos;   next i
           
        FoundBookmarkNo = -1 &apos; index nalezene založky při hledání [::Bookmark::]  
   



 
          



      case &quot;[::Field::]&quot;
        max = getIndexTField(1,0,&quot;&quot;)
        hled = hle(0).hled
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty  
           &apos; nalezen podretezec nebo hledat vsechno
            if (instr(1,tmppole(i).anchor.string,hled,bin)&gt;0)or(hled=&quot;&quot;) then  
              &apos;zjistit kotvu - do oAnch
              oAnch = tmppole(i).anchor &apos; nalezeny objekt
              &apos; je kotva uvnitř vyberu?
              if isInsideOfSelection(oAnch) then  &apos; ano, nalezeno, zamenit
                  prCurs = tmppole(i).anchor &apos; nalezeny objekt
                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = tmppole(i).anchor.string  &apos; textový obsah pole
                  pom = tmppole(i).SupportedServiceNames(0)
                  AltSearchSkup(12) = right(pom,len(pom)-18)  &apos; uno nazev poznamky                        
             
                  nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
             
                  nastavVKurzor(prCurs, false, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny
              
                end if

             end if &apos; nalezen podretezec nebo hledat vsechno
            
            if findcounter &lt; 0 then exit for &apos; prerusit, ukoncit
            StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
           next i
   
   
      case &quot;[::Reference::]&quot;
           hled = hle(0).hled
           getSortFields(tmppole(), tmppole1(), &quot;GetReference&quot;, false)  &apos; rychle načíst netříděné reference
           mode = -1  &apos; -1 = hledání v textu co je vidět (kotvě objektu); 1 = hledat v Názvu (v bublině); 0 = hledat všechno
           if hled = &quot;\\\\&quot; then &apos; hledat prázdný text
               hled = &quot;&quot;
             else
               if left(hled,2)= &quot;\\&quot; then  &apos; hledat v názvu
                 mode = 1
                 hled = rightPast(hled, &quot;\\&quot;)
                else 
                 if hled = &quot;&quot; then  &apos; hledat všechno
                    mode = 0
                   end if
                end if
            end if

           for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů rámců
              if mode = 1 then  &apos; hledat v názvu znacky ?
                  pom = tmppole(i).SourceName
                else &apos; hledat v textu kotvy
                  pom = tmppole(i).anchor.string
                end if

              &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
              &apos; pokud je pom = 0  tak se hledá bez ohledu výskyt hled. podřetězce
              if isSubstrInBlock(tmppole(i),pom,hled,mode) then
                  prCurs = tmppole(i).anchor &apos; nalezeny objekt
                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = prCurs.string  &apos; textový obsah pole 
                  AltSearchSkup(12) = prCurs.start.TextField.SourceName  &apos; nazev zdrojové značky kam se odkazuje   
                  info = AltSearchSkup(12)  &apos; info = uno nazev pole 

                  if mode = 1 then &apos; hledani v názvu ref
                    nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                   else  &apos; hledani v textu kotvy
                    nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                   end if 
                   
                  nastavVKurzor(prCurs, false, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny

                end if &apos; nalezen podretezec

              if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
              StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
            next i

   
   

          
      case &quot;[::Footnote::]&quot;, &quot;[::Endnote::]&quot;
        hled = hle(0).hled

        &apos; \ = hledání v textu poznámky 
        inFoot = -1  &apos; -1 = hledání v kotvě co je vidět (kotvě objektu); 1 = hledat v textu poznamky (bublině); 0 = hledat všechno
        if left(hled,2)= &quot;\\&quot; then  
          inFoot = 1
          hled = rightPast(hled, &quot;\\&quot;)
         end if
        if (hled = &quot;&quot;) then inFoot = 0 &apos; hledat všechny

        if hle(0).cmd = &quot;[::Footnote::]&quot; then
            oFoot = AltSearchDoc.Footnotes
           else
            oFoot = AltSearchDoc.Endnotes
           end if 

        max = oFoot.count - 1  &apos; max index poslední poznamky
        &apos; odkazy na poznamky uschovat do tmppole - při mazaní by se snižoval počet poznamek a doslo by k chybe indexu 
        redim tmppole()
        for i = 0 to max  
            redim preserve tmppole(i)
            tmppole(i)= oFoot(i)  &apos; pole 
          next i
        
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        for i = max to 0 step -1  &apos; pozpátku, jinak při vypouštění poznamky dojde k přečíslování následujících a k nežádoucímu rekurznímu mazaní  
           &apos; hledat v obsahu poznamky nebo v textu kotvy? 
           if inFoot=1 then  
               pom = tmppole(i).string
             else &apos; hledat v textu kotvy
               pom = tmppole(i).anchor.string
             end if
             
           &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
           &apos; pokud je inFoot = 0  tak se hledá bez ohledu výskyt hled. podřetězce
           if isSubstrInBlock(tmppole(i),pom,hled,inFoot) then
                  &apos; u nahrazování se pracuje jen s kotvou, nikdy s texty, podle kterých se ale dá hledat
                  prCurs = tmppole(i).anchor &apos; nalezená kotva
                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = tmppole(i).string  &apos; textový obsah poznamky
                  AltSearchSkup(12) = tmppole(i).anchor.string  &apos; text kotvy                        
                  info = &quot;[&quot;+AltSearchSkup(12)+&quot;]   &quot;+AltSearchSkup(11)
                  
                  if inFoot = 1 then &apos; hledani v textu poznamky
                    nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                   else  &apos; hledani v textu kotvy
                    nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                   end if 
                                     
                  nastavVKurzor(prCurs, false, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny

               end if &apos; nalezene zpracovat


             if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
             StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
           next i


      case &quot;[::ReferenceMark::]&quot;
        hled = hle(0).hled
        inFoot = -1  &apos; -1 = hledání v textu co je vidět (kotvě objektu); 1 = hledat ve Názvu (v bublině); 0 = hledat všechno
        if hled = &quot;\\\\&quot; then &apos; hledat prázdný text
             hled = &quot;&quot;
          else
            if left(hled,2)= &quot;\\&quot; then  &apos; hledat v názvu
              inFoot = 1
              hled = rightPast(hled, &quot;\\&quot;)
             else 
              if hled = &quot;&quot; then  &apos; hledat všechno
                 inFoot = 0
                end if
             end if
          end if
          
        oFoot = AltSearchDoc.ReferenceMarks
        max = oFoot.count - 1  &apos; max index poslední poznamky
        &apos; odkazy na poznamky uschovat do tmppole - při mazaní by se snižoval počet znacek a doslo by k chybe indexu 
        redim tmppole()
        for i = 0 to max  
            redim preserve tmppole(i)
            tmppole(i)= oFoot(i)  &apos; pole 
          next i

        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        &apos; hledat zda vyhovuje podmínkám
        for i = 0 to max 
           &apos; hledat v nazvu značky 
           if inFoot = 1 then  
               pom = tmppole(i).Name
             else &apos; hledat v textu 
               pom = tmppole(i).anchor.string
             end if

           &apos; je hledaný podřetězec HLED obsažen ve VST a je případně uvnitř bloku?
           &apos; pokud je inFoot = 0  tak se hledá bez ohledu výskyt hled. podřetězce
           if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
                  if tmppole(i).anchor.string = &quot;&quot; then &apos; vybrat aby šlo smazat
                    prCurs = tmppole(i).anchor.text.createTextCursorByRange(tmppole(i).anchor.getStart())
                    PrCurs.goRight(1,true)
                   else
                    prCurs = tmppole(i).anchor
                   end if 

                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = prCurs.string &apos; textový obsah 
                  AltSearchSkup(12) = tmppole(i).Name  &apos; nazev značky                        
                  info = AltSearchSkup(12)
                  
                  if inFoot = 1 then &apos; hledani v nazvu
                    nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                   else  &apos; hledalo se v textu
                    nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                   end if 
                  
                  nastavVKurzor(prCurs, false, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny
               

             end if &apos; nalezen text

            if findcounter &lt; 0 then exit for &apos; prerusit ukoncit
            StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
          next i


        

      case &quot;[::TextFrame::]&quot;
        &apos; načíst pomocné pole s názvy objektů (rámců)
        tmppole()= AltSearchDoc.getTextFrames.ElementNames
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů rámců
        
           &apos; nalezen podretezec nebo hledat vsechno
           if (instr(1,tmppole(i),hle(0).hled,bin)&gt;0)or(hle(0).hled=&quot;&quot;) then  

              &apos;zjistit kotvu - do oAnch
              oTmp = AltSearchDoc.getTextFrames.getByName(tmppole(i)) &apos; objekt ramce
              oAnch = getAnchorOfFramePicture(oTmp)

              &apos; je kotva uvnitř vyberu?
              if isInsideOfSelection(oAnch) then &apos; nalezeno, zamenit
                  prCurs = oTmp
                  info = prCurs.Name  &apos; informacni pole pod hledej
                  curinit = false &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = prCurs.string  &apos; textový obsah ramce
                  AltSearchSkup(12) = prCurs.Name  &apos; nazev         
                  
                  nastavSkupiny012(AltSearchSkup(12), hle(0).hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
                  
                  nastavVKurzor(prCurs, curinit, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny

                end if

             end if &apos; nalezen podretezec nebo hledat vsechno

           if findcounter &lt; 0 then exit for &apos; prerusit, ukoncit
           StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
         next i



      case &quot;[::TextTable::]&quot;
           &apos; načíst pomocné pole s názvy objektů (tabulek)
           tmppole()= AltSearchDoc.getTextTables.ElementNames
           if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

           for i = 0 to Ubound(tmppole())  &apos; pro vsechny objekty - pole nazvů tabulek
              &apos; nalezen podretezec nebo hledat vsechno
              if (instr(1,tmppole(i),hle(0).hled,bin)&gt;0)or(hle(0).hled=&quot;&quot;) then  
                &apos;zjistit kotvu - do oAnch
                oTmp = AltSearchDoc.getTextTables.getByName(tmppole(i)) &apos; objekt ramce
                oAnch = getTextRangeOfTable(oTmp)
                &apos; je kotva uvnitř vyberu?
                if isInsideOfSelection(oAnch) then &apos; ano, nalezeno, nahradit
                   pom=oTmp.CellNames(0) &apos; jmeno prvni bunky tabulky
                   ovCurs.gotoRange(oTmp.getCellByName(pom).getStart(),false) &apos; viditelny kurzor na zacatel 1. bunky
                   selectWholeTable(ovCurs)
                   prCurs = oDocControl.selection &apos;getViewCursor()  - pro definitivni vyber 
                   info = oTmp.getName()  &apos; informacni pole pod hledej
                   curinit = false &apos; po nalezeni obcerstvit kurzory - pozor asi zrusi IniBlok pro hledani v bloku!!
                   redim AltSearchSkup(14) &apos; smazat pole se skupinami
                   if repl(0).textobs=1 then 
                     AltSearchSkup(11) = Table2Text(oTmp)  &apos; je-li třeba zkonvertovat textový obsah tabulky
                    end if 
                   AltSearchSkup(12) = info  &apos; nazev  

                   nastavSkupiny012(AltSearchSkup(12), hle(0).hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                         
                   
                          
                   nastavVKurzor(prCurs, curinit, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                   ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                   ReplDo  &apos; provest zameny                

                  end if

               end if &apos; nalezen podretezec nebo hledat vsechno
          
             if findcounter &lt; 0 then exit for &apos; prerusit, ukoncit
             StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
            next i
          
    
      case &quot;[::Picture::]&quot;
        &apos; načíst pomocné pole s názvy objektů (obrázků)
        dim oTFr, names
        oTFr = AltSearchDoc.GraphicObjects
        names = oTFr.ElementNames
        if AltSearchVolby.kcase=0 then bin = 1  &apos; pokud je bin=1 instr(,,bin) nezohlednuje velikost znaků zatim co BIN=0 porovnava presne binarně 

        dim alttext
        alttext = false
        rest = hle(0).hled
        if left(rest,2) = &quot;\\&quot; then  &apos; hledat v Alternativním textu
          for i = 0 to ubound(names)
             &apos; nahradit pole názvů   Alt. texty 
             names(i) = oTFr.getByName(names(i)).Title
           next i        
          rest = rightpast(rest,&quot;\\&quot;)  
          Alttext = true    
        end if
    

        for i = 0 to Ubound(names())  &apos; pro vsechny objekty - pole nazvů obrazků nebo Alt. textů
           &apos; nalezen podretezec nebo hledat vsechno
           if   ( (instr(1,names(i), rest,bin)&gt;0) and (rest&lt;&gt;&quot;&quot;) )   or ( (rest=&quot;&quot;)and(not Alttext) )      or ( Alttext and (names(i)= &quot;&quot;) and (rest= &quot;&quot;)) then  &apos;(instr(1,tmppole(i),hle(0).hled,bin)&gt;0)or(hle(0).hled=&quot;&quot;)
             &apos;zjistit kotvu - do oAnch
             oTmp = AltSearchDoc.GraphicObjects.getByIndex(i) &apos; objekt obrazku
             oAnch = getAnchorOfFramePicture(oTmp)
             &apos; je kotva uvnitř vyberu?
             if isInsideOfSelection(oAnch) then  &apos; ano, nalezeno, zapocitat
                  prCurs = oTmp
&apos;                  info = prCurs.Name  &apos; informacni pole pod hledej
                  curinit = false &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
                  redim AltSearchSkup(14) &apos; smazat pole se skupinami
                  AltSearchSkup(11) = prCurs.Title  &apos; textový obsah ramce - alternativní text
                  AltSearchSkup(12) = prCurs.getName()  &apos; nazev         
                  info = AltSearchSkup(12) + chr(13) 
                  if AltSearchSkup(11)&lt;&gt;&quot;&quot; then info = info + &quot;&gt; &quot; + AltSearchSkup(11) &apos; informacni pole pod hledej

                  &apos; naplneni skupin pro nahrazení
                  pom = hle(0).hled 
                  if left(pom,2) = &quot;\\&quot; then  &apos; hledano v Alternativním textu (Title)
                    pom = rightpast(pom,&quot;\\&quot;)  &apos; zrušit lomitko
                    nastavSkupiny012(AltSearchSkup(11), pom)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                         
                   else &apos; hledano v nazvu
                    nastavSkupiny012(AltSearchSkup(12), pom)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                     
                   end if 

                  nastavVKurzor(prCurs, curinit, info) &apos; nastavit viditelny kurzor na nalezeny objekt
                  ReplCount = ReplCount + 1 &apos; pocitadlo zamen
                  ReplDo  &apos; provest zameny
               end if
               
            end if &apos; nalezen podretezec nebo hledat vsechno
          
           if findcounter &lt; 0 then exit for &apos; prerusit, ukoncit
           StatusInfo(i) &apos; Vypise po urcitem intervalu statusinfo
         next i
          
    

      case &quot;[::BigBlock::]&quot;  &apos; bigBlock
            resetPrCurs &apos; nastavi prCurs v zavislosti na vybranem bloku a volbe bloku

           hledejdal:
            j = FindNextInBlock(hle1(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs
            fo1 = nastavKurzor(prCurs)  &apos; zapamatovat zacatek
            fo2 = fo1.text.createTextCursor()  &apos;nastavKurzor(prCurs)  &apos; stejny region pro fo2

            j = FindNextInBlock(hle2(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs &apos; nenalezeno
            fo3 = nastavKurzor(prCurs)  &apos; vysledek uložit do fo3
            
            if nastavRozsah(fo2, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then
               prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
               goto hledejdal 
              end if 
         
            if AltSearchVolby.zpet = 1 then  &apos; opacne meze pro zpetne hledani
               if nastavRozsah(prCurs, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              else
               if nastavRozsah(prCurs, fo1.getStart(),fo3.getEnd()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              end if  

            &apos; nalezeno, ulozit retezce
            fo1s = fo1.string
            fo2s = fo2.string
            fo3s = fo3.string

            ReplDo  &apos; zamenit nalezene
            ReplCount = ReplCount + 1 &apos; pocitadlo zamen
            ncount = ncount + 1 
            goto hledejDal
          vratcurs:
           goto konec
      
      case else   &apos; standardní regul. výraz
        &apos; normalni regularni vyrazy, s predhledanim
        if not Zamenuj(true) then goto chyba   &apos; vykonna procedura pro PROVEDENI VSECH ZAMEN pomoci hledej - nahrad

     end select 
   
   end if  &apos; hledani s regulárními vyrazy


konec:

  if textFields then update_fields  &apos; je-li potřeba aktualizovat pole &apos; aktualizuje hodnoty textových polí v dokumentu aby po vložení ukazovali správné hodnoty
  nastavVKurzor(AltSiniSel, false, &quot;&quot; ) &apos; obnovit původni vyber
  HledamDisp(false) &apos; pristupne hledani 
  BatReplCount  = BatReplCount + ReplCount  &apos; počitadlo zamen davkoveho zpracovani
  if errProp &gt; 0 then  hlaseni1(16, true, false, msg(23) &amp; errProp &amp; msg(15)) &apos; Počet neúspěšně nastavených vlastností: &apos; styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
  hlaseni(8)  &apos; hledany vyraz ... byl nahrazen ...
  redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole
  ReplCount = 0

  exit sub
  
chyba:
  HledamDisp(false) &apos; pristupne hledani 
end sub



&apos; uloží do nového nebo přidá k existujícímu záznamu
Sub Bt_save1
   SaveBatch(1)
End Sub


&apos; přepne do dialogu spouštění skriptů
Sub Bt_batch
  iniBatch   &apos; inicializuje batch modul, je-li třeba
  oDial.Model.Step = 2  
  
End Sub





&apos; na zaklade zadaneho textoveho objektu patrici do jakekoli bunky tabulky
&apos; vybere celou tabulku viditelnym kurzorem 
sub selectWholeTable(TextBunky)
dim OTmp, pom
if errControl then on error goto konec
 if not isObject(TextBunky.TextTable) then goto konec
 oTmp = TextBunky.TextTable
 pom=oTmp.CellNames(0) &apos; jmeno prvni bunky tabulky
&apos; ovCurs.gotoRange(oTmp.getCellByName(pom).getStart(),false) &apos; viditelny kurzor na zacatel 1. bunky
 oDocControl.select(oTmp.getCellByName(pom).getStart())
 ovCurs = oDocControl.getViewCursor()
 if oTmp.getCellByName(pom).string &lt;&gt; &quot;&quot; then &apos; je-li bunka prazdná, vybere se hned celá tabulka napoprve, 
   dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:SelectAll&quot;, &quot;&quot;, 0, Array()) &apos; vybrat vse 
  end if
 dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:SelectAll&quot;, &quot;&quot;, 0, Array()) &apos; vybrat vse 

konec:
end sub

&apos; sloučí jednotlivé buňky tabulky do jednoho řetězce, oddělené tabulátory a Entery
&apos; celkova delka tabulky je omezena delkou retezce
&apos; NEpočítá se prozatím se složitějším označením sloupců (z více písmen, např. AB)
sub Table2Text(oTmp as object) as string
dim pom, max, i, rest, j 
        &apos; sloučit jednotlivé buňky do jednoho řetězce, oddělené tabulátory a Entery
        pom = &quot;&quot;
        max = 0
        for i = 0 to ubound(oTmp.CellNames())
           rest = oTmp.CellNames(i) + &quot;.&quot; 
           rest = right(rest,len(rest)-1) &apos; prvni znak pryč !! nebude sprábně fungovat pokud bude více sloupců než Z (AA, AB...)
           rest = leftTo(rest,&quot;.&quot;) &apos; vrátit jen první číslo 
           j = clng(rest) &apos; hlavni cislo radku

           if max=0 then 
               if i = 0 then &apos; novy radek, poprve neodrakovat
                  pom = pom + oTmp.getCellByname(oTmp.CellNames(i)).string
                  max = j  
                 end if 
             else  &apos; pokracovani radku tabulky
               if j = max then  &apos; stejny radek
                   pom = pom + chr(9) + oTmp.getCellByname(oTmp.CellNames(i)).string &apos; vlozit tabulator mezi
                 else  &apos; patri uz do nasledujiciho radku
                   pom = pom + chr(13) + oTmp.getCellByname(oTmp.CellNames(i)).string &apos; vlozit enter mezi
                 end if
               max = j  
             end if    

         next i
   Table2Text = pom      
end sub





&apos; procedura hleda podle zadanych globalnich parametru 
&apos; hle0(), hle(), AltSiniSel,
&apos; v AltSLastFound zustava kod vysledku posledniho 0=nalezeno
sub FindDo
dim curs
dim info, curinit
dim max,  bin, i, j, oTmp, pom, hled, rest, mode

 if errControl then on error goto nejakaChyba

  curinit = false &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
  HledamDisp(true) &apos; nepristupne pri hledani 
  findcounter = 1  &apos; obecne pocitadlo pro stavove udaje; minimálně 1 pro možnost přerušení
  &apos; resetovat casti bigbloku
  fo1 = fo0 :  fo2 = fo0 : fo3 = fo0
  fo1s = &quot;&quot; :  fo2s = &quot;&quot; : fo3s = &quot;&quot;
  foundCaseType = 0

hledejZacKon:     
  if AltSearchVolby.reg &lt;&gt; 1 then &apos; normalni hledani bez regularnich výrazů
    if not isSelTextRange(1) then goto konec  &apos; netextovy vyber by zpusobil chybu
    prCurs = ovCurs.text.createTextCursorByRange(ovCurs) &apos; pracovni podle viditelneho
    AltSLastFound = FindNextInBlock(hle(), prCurs, AltSiniSel, false, false) &apos; predhledat bez skupin
   coDelat: 
    select case AltSLastFound 
      case 0  &apos; nalezeno - bez hlaseni
        &apos; pokud se hledal hyperlink tak vypsat info url
         for i = 0 to ubound(SrchAtr())
           if SrchAtr(i).Name = &quot;HyperLinkURL&quot; then info = &quot;\u =  &quot; + prCurs.HyperLinkURL
          next i
         
         &apos; pokud se hledalo označení rejstriku tak vypsat jmeno labelu 
         if (hle(0).atr = 10) or (hle(0).atr = 9) then
           info = &quot;Index label \O =  &quot; + AltSearchSkup(12)
          end if

         &apos; pokud se hledal styl tak vypsat jmeno 
         if (hle(0).atr &gt;= 3) and (hle(0).atr &lt;= 8) then
           info = &quot;\O =  &quot; + AltSearchSkup(12)
          end if


          
        nastavVKurzor(prCurs, curinit, info )  &apos;nastavit viditelny kurzor podle pracovniho
        foundCaseType = getCapitalType(prCurs)

      case -1,1  &apos; 
        hlaseni(0) &apos; Hledání uvnitř bloku dokončeno.
        nastavVKurzor(prCurs, curinit, info )
        prvnipruchod = true  &apos; dalsi hledani znovu od zacatku  bloku znovu 
      case -2
        if 6 &lt;&gt; hlaseni(1) then goto konec &apos;Bylo dosaženo začátku dokumentu. Pokračovat v hledání od konce? 
        nastavVKurzor(prCurs, curinit, info )
        goto hledejZacKon &apos; BtFindNext
      case 2
        if 6 &lt;&gt; hlaseni(2) then goto konec &apos;Bylo dosaženo konce dokumentu. Pokračovat v hledání od začátku?
        nastavVKurzor(prCurs, curinit, info )
        goto hledejZacKon &apos; BtFindNext
      case 4
        hlaseni(4) 

     end select

   else  &apos; hledani s regulárními vyrazy
 &apos;  msgbox prikaz &amp; chr(10) &amp; cmd &amp;  chr(10) &amp; rest 
    select case hle(0).cmd    
      case &quot;[::Note::]&quot;
        hled = hle(0).hled
        AltSLastFound = getNextNote(hled, prCurs, AltSiniSel)    
        info = &quot;&quot;  &apos; informační pole pod &quot;Hledat&quot;
        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        if AltSLastFound = 0 then
            info = prCurs.TextField.content  &apos; textovy obsah poznamky 
            AltSearchSkup(11) = prCurs.TextField.content  &apos; textový obsah poznamky 
            pom = prCurs.TextField.SupportedServiceNames(0)
            AltSearchSkup(12) = right(pom,len(pom)-18)  &apos; uno nazev poznamky   
            
            nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym
          end if

        goto coDelat


      case &quot;[::Field::]&quot;
        hled = hle(0).hled
        AltSLastFound = getNextField(hled, prCurs, AltSiniSel)    
        info = &quot;&quot;  &apos; informační pole pod &quot;Hledat&quot;
        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        if AltSLastFound = 0 then
            AltSearchSkup(11) = prCurs.string  &apos; textový obsah pole 
            pom = prCurs.TextField.SupportedServiceNames(0)
            AltSearchSkup(12) = right(pom,len(pom)-18)  &apos; uno nazev pole   
            info = AltSearchSkup(12)  &apos; info = uno nazev pole 
            
            nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym            
          end if

        goto coDelat





      case &quot;[::Bookmark::]&quot;
        hled = hle(0).hled

        AltSLastFound = getNextBookmark(hled, prCurs, AltSiniSel, mode) &apos; v prCurs je objekt záložky, ne text    
        info = &quot;&quot;  &apos; informační pole pod &quot;Hledat&quot;
        &apos;curinit = true &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
        
        if left(hled,1)= &quot;\\&quot; then  hled = rightpast(hled, &quot;\\&quot;)  &apos; smazat lomítka

        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        if AltSLastFound = 0 then
            AltSearchSkup(11) = prCurs.anchor.String  &apos; text založky
            AltSearchSkup(12) = prCurs.getName()  &apos; nazev     
            info = AltSearchSkup(12) + chr(13) 
            if AltSearchSkup(11)&lt;&gt;&quot;&quot; then info = info + &quot;&quot; + AltSearchSkup(11) &apos; informacni pole pod hledej
            
            prCurs = prCurs.Anchor  &apos; nastavit kurzor na kotvu, tj. do textu podle kotvy

            if mode = 1 then &apos; hledani ve jmenech zalozek
               nastavSkupiny012(AltSearchSkup(12), hled)   

              else  &apos; hledani v textu založky
               nastavSkupiny012(prCurs.String, hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezcem: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
      
              end if  
            
          end if

        goto coDelat

             
            
        
        

      case &quot;[::Reference::]&quot;
        hled = hle(0).hled
        AltSLastFound = getNextReference(hled, prCurs, AltSiniSel,mode)    
        info = &quot;&quot;  &apos; informační pole pod &quot;Hledat&quot;
        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        if AltSLastFound = 0 then
            AltSearchSkup(11) = prCurs.string  &apos; textový obsah pole 
            AltSearchSkup(12) = prCurs.start.TextField.SourceName  &apos; nazev zdrojové značky kam se odkazuje   
            info = AltSearchSkup(12)  &apos; info = uno nazev pole 
            
            if mode = 1 then &apos; hledani v názvu ref
              nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
             else  &apos; hledani v textu kotvy
              nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
             end if             
          end if

         goto coDelat


&apos; debug - pokusny 
        redim tmppole() : redim tmppole1()
        max  = &quot;GetReference&quot; &apos; All GetReference Annotation
        getSortFields(tmppole(), tmppole1(), max, true)  &apos;
        pom = max &amp; &quot; - načteno prvků:  &quot; &amp; ubound(tmppole1()) + 1  &amp; chr(10) &amp; chr(10) 

        for i = 0 to ubound(tmppole1())
           pom = pom + &quot;[&quot; &amp; tmppole1(i) &amp; &quot;]  &quot;   
&apos;           pom = pom + &quot;[&quot; &amp; tmppole1(i) &amp; &quot; &quot; &amp; isBodyTextRegion(tmppole(i).anchor) &amp; &quot;]  &quot; &amp; tmppole(i).anchor.string &amp; chr(10)  

         next i
         
        msgbox pom
        goto konec
        


      case &quot;[::Footnote::]&quot;
        hled = hle(0).hled
        AltSLastFound = getNextFootnote(hled, prCurs, AltSiniSel,&quot;Foot&quot;, mode)    
        info = &quot;&quot;  &apos; informační pole pod &quot;Hledat&quot;
     &apos;   curinit = true &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        if AltSLastFound = 0 then
            AltSearchSkup(11) = prCurs.footnote.string  &apos; textový obsah poznamky 
            AltSearchSkup(12) = prCurs.footnote.anchor.string  &apos; nazev - text kotvy  
            &apos; informační pole pod &quot;Hledat&quot;
            info = &quot;[&quot;+AltSearchSkup(12)+&quot;]   &quot;+AltSearchSkup(11)

            if mode = 1 then &apos; hledani v textu poznamky
               nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
              else  &apos; hledani v textu kotvy
               nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
              end if 

          end if

        goto coDelat
        

      case &quot;[::Endnote::]&quot;
        hled = hle(0).hled
        AltSLastFound = getNextFootnote(hled, prCurs, AltSiniSel,&quot;Endn&quot;, mode)    
&apos;        curinit = true &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
        info = &quot;&quot;  &apos; informační pole pod &quot;Hledat&quot;
        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        if AltSLastFound = 0 then
            AltSearchSkup(11) = prCurs.endnote.string  &apos; textový obsah poznamky 
            AltSearchSkup(12) = prCurs.endnote.anchor.string &apos;  textovy obsah kotvy  
            &apos; informační pole pod &quot;Hledat&quot;
            info = &quot;[&quot;+AltSearchSkup(12)+&quot;]   &quot;+AltSearchSkup(11)

            if mode = 1 then &apos; hledani v textu poznamky
               nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
              else  &apos; hledani v textu kotvy
               nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
              end if             
            
          end if

        goto coDelat



      case &quot;[::ReferenceMark::]&quot;
        hled = hle(0).hled
        AltSLastFound = getNextReferenceMark(hled, prCurs, AltSiniSel, mode)    
        info = &quot;&quot;  &apos; informační pole pod &quot;Hledat&quot;
        &apos;curinit = true &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)
          
        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        if AltSLastFound = 0 then
            AltSearchSkup(11) = prCurs.string  &apos; textový obsah poznamky 
            AltSearchSkup(12) = prCurs.Start.ReferenceMark.Name  &apos; nazev - značky  
            info = AltSearchSkup(12)

            &apos; upravit hled pro nastaveni skupin
            if left(hled,2)= &quot;\\&quot; then  hled = rightPast(hled, &quot;\\&quot;)  &apos; smazat 1. 2 lomítka na začatku
            if left(hled,2)= &quot;\\&quot; then  hled = rightPast(hled, &quot;\\&quot;)  &apos; smazat 2. 2 lomítka na zacatku
            
            if mode = 1 then &apos; hledani v nazvu
              nastavSkupiny012(AltSearchSkup(12), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
             else  &apos; hledalo se v textu
              nastavSkupiny012(AltSearchSkup(11), hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                           
             end if             
          end if

        goto coDelat




      case &quot;[::TextTable::]&quot;
        max = getIndexTextTable(1,0,&quot;&quot;)
        i =  getIndexTextTable(0,0,&quot;&quot;)
       opakTTable: 
        if hle(0).hled = &quot;&quot; then  &apos; jdi na dalsi ramec
           if not vyhodnotHledani(i,max) then goto konec  &apos; nastavi i na dalsi/predchozi objekt 
          else &apos; vyhledat
           i =  getIndexTextTable(2,i,hle(0).hled)  &apos; najít podretezec
           if (i&lt;0) or (i&gt;max) then &apos; podretezec nenalezen
              if not vyhodnotHledani(i,max) then goto konec  &apos; nastavi i na dalsi objekt 
              if i=0 then i = -1      &apos; dal hledat od zacatku
              if i=max then i = max+1  &apos; dal hledat od konce
              goto opakTTable         
             end if
          end if      

        oTmp = AltSearchDoc.getTextTables.getbyIndex(i) &apos; objekt tabulky
        pom=oTmp.CellNames(0) &apos; jmeno prvni bunky tabulky
        &apos; ovCurs.gotoRange(oTmp.getCellByName(pom).getStart(),false) &apos; viditelny kurzor na zacatel 1. bunky
        oDocControl.select(oTmp.getCellByName(pom).getStart())
        ovCurs = oDocControl.getViewCursor()
        selectWholeTable(ovCurs)
        prCurs = oDocControl.selection &apos;getViewCursor()  - pro definitivni vyber 
        info = oTmp.getName()  &apos; informacni pole pod hledej
        curinit = true &apos; po nalezeni obcerstvit kurzory - pozor asi zrusi IniBlok pro hledani v bloku!!
        AltSLastFound = 0  &apos; příznak nalezeni

        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        &apos; sloučit jednotlivé buňky do jednoho řetězce, oddělené tabulátory a Entery
         
        AltSearchSkup(11) = Table2Text(oTmp)  &apos; textový obsah tabulky 
        AltSearchSkup(12) = info  &apos; nazev tabulky

        nastavSkupiny012(AltSearchSkup(12), hle(0).hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym

        goto coDelat


      case &quot;[::TextFrame::]&quot;
        max = getIndexTextFrame(1,0,&quot;&quot;)
        i =  getIndexTextFrame(0,0,&quot;&quot;)
       opaktextframe: 
        if hle(0).hled = &quot;&quot; then  &apos; jdi na dalsi ramec
           if not vyhodnotHledani(i,max) then goto konec  &apos; nastavi i na dalsi/predchozi objekt 
          else &apos; vyhledat
           i =  getIndexTextFrame(2,i,hle(0).hled)  &apos; najít podretezec
           if (i&lt;0) or (i&gt;max) then &apos; podretezec nenalezen
              if not vyhodnotHledani(i,max) then goto konec  &apos; nastavi i na dalsi objekt 
              if i=0 then i = -1      &apos; dal hledat od zacatku
              if i=max then i = max+1  &apos; dal hledat od konce
              goto opaktextframe
             end if
          end if 
        
        prCurs = AltSearchDoc.getTextFrames.getbyIndex(i) &apos; nalezeny objekt
        info = prCurs.Name  &apos; informacni pole pod hledej
        curinit = true &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
        AltSLastFound = 0  &apos; příznak nalezeni
        redim AltSearchSkup(14) &apos; smazat pole se skupinami
        AltSearchSkup(11) = prCurs.string  &apos; textový obsah ramce
        AltSearchSkup(12) = info  &apos; nazev         

        nastavSkupiny012(AltSearchSkup(12), hle(0).hled)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym

        goto coDelat


      case &quot;[::Picture::]&quot;
        max = getIndexPicture(1,0,&quot;&quot;)
        i =  getIndexPicture(0,0,&quot;&quot;)
       opakPicture: 
        if hle(0).hled = &quot;&quot; then  &apos; jdi na dalsi ramec
           if not vyhodnotHledani(i,max) then goto konec  &apos; nastavi i na dalsi/predchozi objekt 
          else &apos; vyhledat
           i =  getIndexPicture(2,i,hle(0).hled)  &apos; najít podretezec
           if (i&lt;0) or (i&gt;max) then &apos; podretezec nenalezen
              if not vyhodnotHledani(i,max) then goto konec  &apos; nastavi i na dalsi objekt 
              if i=0 then i = -1      &apos; dal hledat od zacatku
              if i=max then i = max+1  &apos; dal hledat od konce
              goto opakPicture
             end if
          end if 

        prCurs = AltSearchDoc.GraphicObjects.getbyIndex(i) &apos; nalezeny objekt
&apos;        oDocControl.select(prCurs)
&apos;        msgbox i

        curinit = true &apos; po nalezeni obcerstvit kurzory pomoci CursorInit(true)  
        AltSLastFound = 0  &apos; 
        redim AltSearchSkup(14) &apos; smazat pole se skupinami


        AltSearchSkup(11) = prCurs.Title  &apos; textový obsah ramce - cely alternativní text
        AltSearchSkup(12) = prCurs.getName()  &apos; nazev         
        info = AltSearchSkup(12) + chr(13) 
        if AltSearchSkup(11)&lt;&gt;&quot;&quot; then info = info + &quot;&gt; &quot; + AltSearchSkup(11) &apos; informacni pole pod hledej
   
        &apos; naplneni skupin pro nahrazení
        pom = hle(0).hled 
        if left(pom,2) = &quot;\\&quot; then  &apos; hledano v Alternativním textu (Title)
            pom = rightpast(pom,&quot;\\&quot;)  &apos; zrušit lomitko
            nastavSkupiny012(AltSearchSkup(11), pom)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                         
          else &apos; hledano v nazvu
            nastavSkupiny012(AltSearchSkup(12), pom)   &apos; nastaví promenne AltSearchSkup(0-2) podle parametru hledání podretezce: 1=před nalezeným 0=nalezeny 2=za nalezenym                                     
          end if 

        goto coDelat



      case &quot;[::BigBlock::]&quot;  &apos; bigBlock
            prCurs = nastavKurzor(ovCurs)  &apos; pracovni podle viditelneho
           hledejdal:
            j = FindNextInBlock(hle1(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs
            fo1 = nastavKurzor(prCurs)  &apos; zapamatovat zacatek
            fo2 = fo1.text.createTextCursor()  &apos;nastavKurzor(prCurs)  &apos; stejny region pro fo2

            j = FindNextInBlock(hle2(), prCurs, AltSiniSel, false, false)
            if j &lt;&gt; 0 then goto vratcurs &apos; nenalezeno
            fo3 = nastavKurzor(prCurs)  &apos; vysledek uložit do fo3
            
            if nastavRozsah(fo2, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then
               prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
               goto hledejdal 
              end if 
         
            if AltSearchVolby.zpet = 1 then  &apos; opacne meze pro zpetne hledani
               if nastavRozsah(prCurs, fo1.getEnd(),fo3.getStart()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              else
               if nastavRozsah(prCurs, fo1.getStart(),fo3.getEnd()) &lt;&gt; 0 then  
                 prCurs = nastavKurzor(fo1) &apos; případe chyby regiony zacit hledat dal za fo1
                 goto hledejdal 
                end if 
              end if  
           
            &apos; nalezeno, ulozit retezce
            fo1s = fo1.string
            fo2s = fo2.string
            fo3s = fo3.string
            nastavVKurzor(prCurs, curinit, info )  &apos; zobrazit vysledek
            AltSLastFound = 0 &apos; nenalezeno              
            goto konec         

          vratcurs:
           if (j=-1)or(j=1) then
              hlaseni(0) &apos; Hledání uvnitř bloku dokončeno.
              nastavVKurzor(AltSiniSel, info, curinit)  &apos;nastavit viditelny kurzor podle pracovniho
              prvnipruchod = true
             else 
              if AltSearchVolby.zpet = 1 then  &apos; opacne meze pro zpetne hledani        
                 if 6 &lt;&gt; hlaseni(1) then goto konec &apos;Bylo dosaženo začátku dokumentu. Pokračovat v hledání od konce? 
                 ovCurs.gotorange(AltSearchDoc.text.getEnd(),false) &apos; kurzor na konec dokumentu
                 goto hledejZacKon &apos; BtFindNext  
                else        
                 if 6 &lt;&gt; hlaseni(2) then goto konec &apos;Bylo dosaženo konce dokumentu. Pokračovat v hledání od začátku? 
                 ovCurs.gotorange(AltSearchDoc.text.getStart(),false) &apos; korzor na začátek dokumentu
                 goto hledejZacKon &apos; BtFindNext                 
                end if 
             end if
           AltSLastFound = 10 &apos; kod nenalezeno  
           goto konec

      
      case else   &apos; standardní regul. výraz
        &apos; normalni rgularni vyrazy
        if not isSelTextRange(1) then goto konec  &apos; netextovy vyber by zpusobil chybu
        prCurs = ovCurs.text.createTextCursorByRange(ovCurs) &apos; pracovni podle viditelneho
        AltSLastFound = FindNextInBlock(hle(), prCurs, AltSiniSel, false, false) &apos; predhledat bez skupin
        if (AltSLastFound = 0)and (AltSearchVolby.reg=1)and not( (ubound(hle1())=0) and ((hle1(0).hled=&quot;$&quot;) or (hle1(0).atr=4) ) ) then  &apos;bez skupin bylo nalezeno - znovu prohledat se skupinami, jen pri regularnich symbolech a ne při hledaní samotneho $ a ne při hledani znakoveho stylu
            Curs = prCurs.text.createTextCursorByRange(prCurs) &apos; pomocny podle pracovniho kurzoru
            if AltSearchVolby.zpet = 1 then
               Curs.collapseToEnd
               &apos; když je kurzor na zacatku odstavce, OOo hledaní pozpatku najde až další zacatek odstavce - takže pokud se hledá začátek odstavce tak to přeskakuje  
               &apos; mělo by být vyřešeno přidáním podmínky vylučující hledání samotného &quot;$&quot; 
&apos;               if curs.isStartOfParagraph and hle1(0).hled=&quot;$&quot; then curs.goRight(1,false)  &apos; vratit o jedno zpět
              else
               Curs.collapseToStart
               &apos; když je kurzor na konci odstavce, OOo hledaní najde až další konec odstavce - takže pokud se hledá konec odstavce tak to přeskakuje  
&apos;               if curs.isEndOfParagraph and hle1(0).hled=&quot;$&quot; then curs.goLeft(1,false)  &apos; vratit o jedno zpět
              end if  
            AltSLastFound = FindNextInBlock(hle1(), Curs, AltSiniSel, false, false) &apos; hledat podle skupin
          end if

        goto coDelat  
      
     end select 
   
   end if  &apos; hledani s regulárními vyrazy

konec:

        
  HledamDisp(false) &apos; pristupne hledani 
  &apos; kvůli bugu na Linuxu - v předchozí procedure se nepochopitelně zresetuje info text
  &apos; pokud byl hledán objekt a bylo použito ...Window.setVisible()
  &apos;vypisFoundInfo(itext)    &apos; nic z toho nefunguje, nedovedu momentálně vyřešit 
  &apos;oDial.model.Lb_info.label = info
  &apos;oDial.getControl(&quot;Lb_info&quot;).model.label = info
  &apos;xray oDial.getControl(&quot;Lb_info&quot;).model.label  &apos;.model.Lb_info

  exit sub
  
nejakaChyba:
  if left(hle(0).cmd,3) = &quot;[::&quot; then
     if prvnipruchod then redim tmppole() &apos; resetovat pole používane hledani rámců, poznamek, footnoote, a text. pole
     beep
    else
     hlaseni1(48, false, false, &quot;FindDo: Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
    end if   
  resume next
end sub





&apos; vraci textovou kotvu vybraneho objektu
&apos; pokud vrátí null tak je kotva ke stránce - číslo stránky je v oDocControl.selection.AnchorPageno
&apos; Pokud je vysledek v outMsg &quot;tab&quot; pak je odkaz na 1. bunku tabulky
sub getAnchorOfObj() as object
dim null as object
dim nam, cur, pom, oSel 

 if errControl then on error goto nejakaChyba

  outMsg = &quot;&quot;  &apos; verejna promenna s doplnujicimi vysledky funkce
  &apos; v nam je typ vybraneho objektu, např. &quot;SwXTextFrame&quot;
  nam = oDocControl.selection.ImplementationName
  select case nam  &apos; umístit prCurs pokud možno ke kotvě, aby se případný vkládaný text umistil k objektu
    &apos; textovy blok
    case &quot;SwXTextRanges&quot;
&apos;      xray oDocControl.ViewCursor          &apos;selection
      getAnchorOfObj = null
      outMsg = &quot;text&quot; &apos; priznak toho ze jde o textovy objekt - nechat byt?

    &apos; obrazky a textove ramce
    case &quot;SwXTextFrame&quot;, &quot;SwXTextGraphicObject&quot;  
      oSel = oDocControl.selection
      select case oSel.AnchorType &apos; podle typu ukotveni
        case com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH
          &apos; na začátek odstavce
          cur = oSel.Anchor.text.createtextCursorByRange(oSel.Anchor.getStart()) &apos; do mista kotvy, muze byt kdekoli v odstavci
          cur.gotoStartOfParagraph(false)
          getAnchorOfObj = cur.getStart()    &apos; při null nastavit zacatek odstavce
          
        case com.sun.star.text.TextContentAnchorType.AS_CHARACTER, com.sun.star.text.TextContentAnchorType.AT_CHARACTER
          &apos; jako znak, ke znaku - přímo kotva
          getAnchorOfObj = oSel.Anchor.getStart()
          
        case com.sun.star.text.TextContentAnchorType.AT_PAGE 
          &apos; ke strance 
          getAnchorOfObj = null &apos; oDocControl.selection.AnchorPageno
          &apos; vratit cislo zakotvene stranky
          outMsg = &quot;&quot; &amp; oSel.AnchorPageno 
        
        case com.sun.star.text.TextContentAnchorType.AT_FRAME 
          &apos; na začátek textu ramce
          getAnchorOfObj = oSel.AnchorFrame.getStart  
      end select   


    &apos; tabulky
    case &quot;SwXTextTableCursor&quot;
      &apos; jmeno prvni bunky tabulky
      pom=oDocControl.ViewCursor.TextTable.CellNames(0)
      &apos; zacatel 1. bunky
      getAnchorOfObj = oDocControl.ViewCursor.TextTable.getCellByName(pom).getStart()
      outMsg = &quot;tab&quot; &apos; priznak toho ze odkaz je na 1. bunku tabulky 
           
    case &quot;com.sun.star.drawing.SvxShapeCollection&quot;                        
&apos;      xray oDocControl.selection.getByIndex(0)
      oSel = oDocControl.selection.getByIndex(0)
      select case oSel.AnchorType &apos; podle typu ukotveni
        case com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH
          &apos; na začátek odstavce
          cur = oSel.Anchor.text.createtextCursorByRange(oSel.Anchor.getStart()) &apos; do mista kotvy, muze byt kdekoli v odstavci
          cur.gotoStartOfParagraph(false)
          getAnchorOfObj = cur.getStart()    &apos; při null nastavit zacatek odstavce
          
        case com.sun.star.text.TextContentAnchorType.AS_CHARACTER, com.sun.star.text.TextContentAnchorType.AT_CHARACTER
          &apos; jako znak, ke znaku - přímo kotva
          getAnchorOfObj = oSel.Anchor.getStart()
          
        case com.sun.star.text.TextContentAnchorType.AT_PAGE 
          &apos; ke strance 
          getAnchorOfObj = null &apos; oDocControl.selection.AnchorPageno
          &apos; vratit cislo zakotvene stranky
          outMsg = &quot;&quot; &amp; oSel.AnchorPageno 
        
        case com.sun.star.text.TextContentAnchorType.AT_FRAME 
          &apos; na začátek textu ramce
          getAnchorOfObj = oSel.AnchorFrame.getStart  
      end select   
      getAnchorOfObj = null
            
    case else
      hlaseni1(32, true, false, &quot;getAnchorOfObj():  Unknown object:  &quot; &amp; nam) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
      getAnchorOfObj = null
             
   end select 

  exit sub
  
nejakaChyba:
  hlaseni1(48, true, false, &quot;getAnchorOfObj():  Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
  getAnchorOfObj = null
end sub



&apos; vraci textovy rozsah s tabulkou zadanou 
sub getTextRangeOfTable(oTbl as object) as object
dim pom, curs
 pom=oTbl.CellNames(0) &apos; jmeno prvni bunky tabulky
 ovCurs.gotoRange(oTbl.getCellByName(pom).getStart(),false) &apos; viditelny kurzor na zacatel 1. bunky
 ovCurs.goLeft(1,false) &apos; pred tabulku
 curs = ovCurs.text.createTextCursorByRange(ovCurs.getStart()) &apos; pocatecni znacku podle viditelneho
 ovCurs.goDown(1,true) &apos; vybrat celou tabulku aby sla vystrihnout pryč
 ovcurs.gotoStartofLine(true)
 curs.gotoRange(ovCurs.getEnd(),true)
 getTextRangeOfTable = curs 
end sub



&apos; vraci kotvu textoveho ramce nebo obrazku
sub getAnchorOfFramePicture(oTmp as object)as object
dim typKotvy, pom
typKotvy = oTmp.AnchorType
 select case typKotvy &apos; podle typu ukotveni
   case com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH
      &apos; na začátek odstavce
      pom = oTmp.Anchor.text.createtextCursorByRange(oTmp.Anchor.getStart()) &apos; do mista kotvy, muze byt kdekoli v odstavci
      pom.gotoStartOfParagraph(false)
      getAnchorOfFramePicture = pom
          
   case com.sun.star.text.TextContentAnchorType.AS_CHARACTER, com.sun.star.text.TextContentAnchorType.AT_CHARACTER
      &apos; jako znak, ke znaku - přímo kotva
      getAnchorOfFramePicture = oTmp.Anchor.getStart()
          
   case com.sun.star.text.TextContentAnchorType.AT_PAGE 
      &apos; ke strance - nastavit viditelny kurzor na cislo stranky
      oVcurs.JumpToPage(oTmp.AnchorPageno) 
      getAnchorOfFramePicture = oVcurs.text.createTextCursorByRange(oVcurs.getStart) &apos; zjistit rozsah
  
   case com.sun.star.text.TextContentAnchorType.AT_FRAME 
      &apos; na začátek textu ramce
      getAnchorOfFramePicture = oTmp.AnchorFrame.getStart
 
 end select   
 
end sub



&apos; procedura nahradi podle predpisu REPL blok definovany prCurs
&apos; pokud je blok prCurs vetsi než 64 kb, tak pouzije viditelny kurzor
&apos; interni funkce OOo pomoci dispatchHelper
&apos; predpoklada ze prCurs je nalezeny text
sub ReplDo
dim clipbMode as boolean  &apos; příznak aktivujici vkládání objektů/textu z clipboardu misto jen z textu cursor.string() 
dim Bmark, markPrac, oSel    &apos; značka pro zacatku nahrazeneho/vkládaneho textu a prac. znacka, vybrany objekt curentcontroller.selection
dim markD, markH, markP, markC, markN, markProp, markK   &apos; pracovni značky pro nastaveni stylů a properties
dim i, sk, pom, pom1

dim oFoot, oFootCurs &apos; pro vytvoření Foot/Endnote
dim noTextOb, obnovVcurs as boolean
dim mistochyby as string
dim oriCurs &apos; puvodni prac. kurzor; používá se při přesměrování
dim mode

&apos; HledamDisp(true) &apos; nepristupne hledani 
 mistochyby = &quot;&quot;
 if errControl then on error goto nejakaChyba


&apos; \ = hledání ve jemenech založek 
 mode = -1  &apos; -1 = hledání v textu zalozky; 1 = hledat ve jmenech založek; 0 = hledat jakoukoli založku
 if left(hle(0).hled,2)= &quot;\\&quot; then  mode = 1
 if hle(0).hled = &quot;&quot; then mode = 0 &apos; hledat všechny  


 noTextOb = false &apos; predpoklada se textovy objekt
 clipbMode = false &apos; vkladani pres clipboard
 obnovVcurs = false &apos; po skonceni vkladani nastavit viditelny kurzor ovCurs podle prCurs, po pouziti clipboardu. 

 &apos; přesměrovat nahrazeni (\R) do okna/ramce AltSearchPrintOut ?
 if AltSearchPrintOut = &quot;&quot; then &apos; ne
  oriCurs = prCurs  &apos; zapamatovat původní prac kurzor - měl by to být nalezený text nebo objekt - 
  
  &apos; bude treba objekt smazat? (nebo se budou jen měnit vlastnosti?)
  If repl(0).smaz = 1 then &apos; ano smazat
      if repl(0).vloz = 1 then &apos; v nahrazovacim poli je obsažen nalezeny text &quot;&amp;&quot;, pokud je to objekt nebo dlouhý text tak smazat do clipboardu
         if (repl(0).form = 1)or(isBigText_Or_NonTextObject(oDocControl.getViewCursor())) then &apos; je to text nad 64k nebo je to objekt, tabulka?

             if (hle(0).cmd = &quot;[::Bookmark::]&quot;)and (mode = 1) then goto stornoClipboard: &apos; při hledání založek podle jmena vypnout přenášení přes clipb - jinak chybná detekce textu v tabulkach
   
             &apos; bude dale použit - smazat do clipboardu
             clipbMode = true
             if hle(0).cmd = &quot;[::BigBlock::]&quot; then
                  &apos; u velkeho blok jen prostredek
                  fo1.string = &quot;&quot;  &apos; znacky pryc
                  fo3.string = &quot;&quot;
                  &apos; prostredek zachovat
                  nastavVKurzor(fo2, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle stredniho bloku
                  dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:Cut&quot;, &quot;&quot;, 0, Array())
                else  &apos; vystrihnout objekt
                  &apos; umístit prCurs pokud možno ke kotvě, aby se případný vkládaný text umistil k objektu
                  &apos; vrátí ukotveni objektu do textu pro nastavení prCurs
                  nastavVKurzor(prCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle pracovniho
                  markPrac = getAnchorOfObj()
                  select case outMsg  &apos; pomocny vysledek, idikace tabulky
                    case &quot;text&quot;
                     &apos; pokud je nalezeno samotné pole žluté poznámky, tak upravit prCurs posunout doprava aby se vybralo celé pole
                     &apos; jinak to v linuxu nefunguje
                     &apos; ale nakonec zrušeno, protože při Nahradit vše nefunguje dobře zdvojuje vkládaný obsah
                   &apos;   if isObject(ovCurs.TextField) then &apos; : if ovCurs.TextField.anchor.string = &quot;&quot; then : ovCurs.goRight(1,true) : end if : end  if
                   &apos;         if (ovCurs.TextField.anchor.string = &quot;&quot;)and(ovCurs.TextField.SupportedServiceNames(0)=&quot;com.sun.star.text.TextField.Annotation&quot;) then 
                   &apos;           ovCurs.goRight(1,true)   &apos;TextField.SupportedServiceNames(0)
                   &apos;          end if 
                   &apos;      end if 
                      Bmark = prCurs.text.createTextCursorByRange(prCurs.getStart())
                      
                    case &quot;&quot;  &apos; netextovy objekt obrazek, ramec - mozno primo nastavit prCurs, kotva ke znaku, odstavci
                      Bmark = markPrac.text.createTextCursorByRange(markPrac.getStart())
                      noTextOb = true
              
                    case &quot;tab&quot; &apos; nutno presunout kurzor pred tabulku, anchor z tabulky nefunguje, takze pres viditelny kurzor 
                      ovCurs.gotoRange(markPrac, false) &apos;nastavit viditelny kurzor podle odkazu - na zacaek 1. bunky
                      ovCurs.goLeft(1,false) &apos; pred tabulku
                      Bmark = ovCurs.text.createTextCursorByRange(ovCurs.getStart()) &apos; pocatecni znacku podle viditelneho
                      ovCurs.goDown(1,true) &apos; vybrat celou tabulku aby sla vystrihnout pryč
                      ovcurs.gotoStartofLine(true)

                    case else &apos; melo by to byt cislo stranky pri kotveni ke strance
                      &apos; na zacatek stranky, pres viditelny kurzor
                      oDocControl.ViewCursor.JumpToPage(val(outMsg)) 
                      Bmark = ovCurs.text.createTextCursorByRange(ovCurs) &apos;  pocatecni znacku podle viditelneho
                      oDocControl.select(prCurs)  &apos; znovu vybrat objekt

               end select
                 
                  dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:Cut&quot;, &quot;&quot;, 0, Array())
                  &apos; prcurs na zacatek Bmark - kotvy
                  prCurs = Bmark.text.createTextCursorByRange(Bmark)
                  Bmark = prCurs.getStart()

              end if  &apos; vystrihnout objekt

           else  &apos; smazat jako text
             &apos; pokud je nalezeno samotné pole tak upravit prCurs posunout doprava aby se vybralo celé pole
         &apos;    if isObject(prCurs.TextField) then prCurs.goRight(1,true)
             prCurs.string = &quot;&quot; &apos; smazat jako text
             Bmark = prCurs.getStart()
           end if  &apos; smazat text nad 64k nebo objekt nebo smazat jako text do 64k 
      
        else  &apos; neni pouzito &quot;&amp;&quot; - v nahrazeni nebude vložen obsah nalezeneho text/objekt
         if isBigText_Or_NonTextObject(oDocControl.getViewCursor()) then &apos; je to text nad 64k nebo je to objekt, tabulka?
             &apos; smazat pomoci Uno aby se zbytecne neblokoval Clipboard
             if hle(0).cmd = &quot;[::BigBlock::]&quot; then  &apos; smazat big-blok
                  dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:Delete&quot;, &quot;&quot;, 0, Array())
                else &apos; smazat obecny objekt
                  &apos; umístit prCurs pokud možno ke kotvě, aby se případný vkládaný text umistil k objektu
                  &apos; vrátí ukotveni objektu do textu pro nastavení prCurs
                  markPrac = getAnchorOfObj()
                  select case outMsg  &apos; pomocny vysledek, idikace tabulky
                    case &quot;text&quot;
                      Bmark = prCurs.text.createTextCursorByRange(prCurs.getStart())

                    case &quot;&quot;  &apos; netextovy objekt obrazek, ramec - mozno primo nastavit prCurs, kotva ke znaku, odstavci
                      Bmark = markPrac.text.createTextCursorByRange(markPrac.getStart())
                      noTextOb = true
              
                    case &quot;tab&quot; &apos; nutno presunout kurzor pred tabulku, anchor z tabulky nefunguje, takze pres viditelny kurzor 
                      ovCurs.gotoRange(markPrac, false) &apos;nastavit viditelny kurzor podle odkazu - na zacaek 1. bunky
                      ovCurs.goLeft(1,false) &apos; pred tabulku
                      Bmark = ovCurs.text.createTextCursorByRange(ovCurs.getStart()) &apos; pocatecni znacku podle viditelneho
                      ovCurs.goDown(1,true) &apos; vybrat celou tabulku aby sla vystrihnout pryč
                      ovcurs.gotoStartofLine(true)

                    case else &apos; melo by to byt cislo stranky pri kotveni ke strance
                      &apos; na zacatek stranky, pres viditelny kurzor
                      oDocControl.ViewCursor.JumpToPage(val(outMsg)) 
                      Bmark = ovCurs.text.createTextCursorByRange(ovCurs) &apos;  pocatecni znacku podle viditelneho
                      oDocControl.select(prCurs)  &apos; znovu vybrat objekt

               end select

                  dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:Delete&quot;, &quot;&quot;, 0, Array())
                  &apos; prcurs na zacatek Bmark - kotvy
                  prCurs = Bmark.text.createTextCursorByRange(Bmark)
                  Bmark = prCurs.getStart()

             end if 
           else  &apos; smazat jako text
             &apos; pokud je nalezene samotné pole tak upravit prCurs posunout doprava aby se vybralo celé pole
  &apos;           if isObject(prCurs.TextField) then prCurs.goRight(1,true)
             prCurs.string = &quot;&quot; &apos; smazat jako text,     
             Bmark = prCurs.getStart()      
                   
           end if

        end if
        
&apos;       Bmark = prCurs.getStart()
       
    else &apos; nemazat, budou se jen měnit vlastnosti
&apos;          inputbox &quot;&quot; , &quot;&quot;,  pom
       &apos; snaha umistit prCurs jasne definovane misto: ke kotvě vybraneho objektu
       markPrac = getAnchorOfObj() &apos; snazi se vratit kotvu vybraneho objektu v textu
       select case outMsg  &apos; pomocny vysledek, idikace tabulky
            case &quot;text&quot;
              &apos; pokud je nalezene samotné text. pole tak upravit prCurs: posunout doprava aby se vybralo celé pole
  &apos;            if isObject(prCurs.TextField) then prCurs.goRight(1,true)
              Bmark = prCurs.getStart()
              
            case &quot;&quot;  &apos; netextovy objekt obrazek, ramec - mozno primo nastavit prCurs, kotva ke znaku, odstavci
              oSel = oDocControl.selection  &apos; odkaz na vybrany objekt
              noTextOb = true  &apos; příznak netextového objektu
              Bmark = markPrac.text.createTextCursorByRange(markPrac) &apos; texty ke kotve
              prCurs = Bmark.text.createTextCursorByRange(Bmark) &apos; dalsi vkladat za objekt
              
            case &quot;tab&quot; &apos; nutno presunout kurzor pred tabulku, anchor z tabulky nefunguje, takze pres viditelny kurzor 
              oSel = oDocControl.selection  &apos; odkaz na vybranou tabulku (cellRange)
              noTextOb = true  &apos; příznak netextového objektu
              ovCurs.gotoRange(markPrac, false) &apos;nastavit viditelny kurzor podle odkazu - na zacaek 1. bunky
              ovCurs.goLeft(1,false) &apos; pred tabulku
              Bmark = ovCurs.text.createTextCursorByRange(ovCurs) &apos; pocatecni znacku podle viditelneho
              prCurs = Bmark.text.createTextCursorByRange(Bmark) &apos; dalsi vkladat za objekt


            case else &apos; melo by to byt cislo stranky pri kotveni ke strance
              oSel = oDocControl.selection  &apos; odkaz na vybrany objekt ukotveny ke strance
              noTextOb = true  &apos; příznak netextového objektu
              &apos; na zacatek stranky, pres viditelny kurzor
              oDocControl.ViewCursor.JumpToPage(val(outMsg)) 
              Bmark = ovCurs.text.createTextCursorByRange(ovCurs) &apos;  pocatecni znacku podle viditelneho
              prCurs = Bmark.text.createTextCursorByRange(Bmark) &apos; dalsi vkladat za objekt

         end select

    end if

    
   else &apos; přesměrovat nahrazeni (\R) do okna/ramce AltSearchPrintOut 

     oriCurs = prCurs  &apos; zapamatovat původní prac kurzor - měl by to být nalezený text nebo objekt
     prCurs = prCurs1  &apos; přesměrovat prCurs do souboru výpisu 
     Bmark = prCurs.getStart() &apos; nastavit zakladní značku začátku v souboru výpisu 
     
     &apos; bude potřeba schranka ?
     if (repl(0).form = 1)or(isBigText_Or_NonTextObject(oDocControl.getViewCursor())) then &apos; je to text nad 64k nebo je to objekt, tabulka

        if (hle(0).cmd = &quot;[::Bookmark::]&quot;)and (mode = 1) then goto stornoClipboard: &apos; při hledání založek podle jmena vypnout přenášení přes clipb - jinak chybná detekce textu v tabulkach
        &apos; bude použita schránka
        clipbMode = true
        if hle(0).cmd = &quot;[::BigBlock::]&quot; then
             &apos; u velkeho bloku kopirovat jen prostredek
             nastavVKurzor(fo2, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle stredniho bloku
           else
             nastavVKurzor(oriCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor
             &apos; je-li nalezeno textove pole tak rozšířit kurzor pro kopirovani
    &apos;         if isObject(ovCurs.TextField) then ovCurs.goRight(1,true)
             
           end if  &apos; nejaky netextovy objekt

        &apos; kopirovat
        dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:Copy&quot;, &quot;&quot;, 0, Array())
       end if
     

   end if &apos; přesměrovat nahrazeni (\R) do okna/ramce AltSearchPrintOut
&apos;    xray prCurs


stornoClipboard:
 &apos; nastavit všechny znacky na zacatek nalezeneho textu/objektu??? 
 &apos; zajistit nekonfliktni polohu prCurs!!!
&apos; Bmark = prCurs.getStart()
 markH = Bmark :  markP = Bmark :  markC = Bmark :  markN = Bmark :  markProp = Bmark
 markD = Bmark :  markK = Bmark

 for i = 0 to ubound(Repl())
   select case repl(i).cmd
    case &quot;$&quot; &apos; vložit retezec
      if repl(i).nahr &lt;&gt; &quot;&quot; then
         select case foundCaseType &apos; 0=bez uprav, nechat být; 1=první velké; 2=všechna velká;  - číslo určující při nalezení retězce jeho typ z hlediska velikosti znaků
          case 1
            pom = lcase( repl(i).nahr )  &apos; vlozit malými pismeny s prvním velkým          
            if i = 0 then pom = ucase(left(pom,1)) &amp; right(pom, len(pom)-1)  &apos; první písmeno převest na velké
            prCurs.string = pom
          case 2 
            prCurs.string = ucase( repl(i).nahr )  &apos; vlozit velkymi pismeny
          case else 
            prCurs.string = repl(i).nahr  &apos; vlozit text beze zmen
          end select         

          prCurs.collapseToEnd   

       end if  

    case &quot;b&quot; &apos; vložit pocatecni značku velkeho bloku
      if fo1s &lt;&gt; &quot;&quot; then
         prCurs.string = fo1s  &apos; vlozit text
       else
         prCurs.string =  AltSearchSkup(1) 
       end if  
      
      prCurs.collapseToEnd
      
    case &quot;e&quot; &apos; vložit konecnou značku velkeho bloku
      if fo3s &lt;&gt; &quot;&quot; then
         prCurs.string = fo3s  &apos; vlozit text
       else
         prCurs.string =  AltSearchSkup(2) 
       end if  

      prCurs.collapseToEnd

    case &quot;i&quot; &apos; vložit počitadlo náhrad
      &apos; počáteční hodnota
      if repl(i).nahr = &quot;&quot; then pom = 0  else pom = val(leftTo(repl(i).nahr,&quot;,&quot;)) - 1
      &apos; formát čísla - počet míst
      pom1 = String(val(rightPast(repl(i).nahr,&quot;,&quot;)),&quot;0&quot;)
      
      prCurs.string = Format(ReplCount + pom, pom1)  &apos; vlozit text
      prCurs.collapseToEnd

    case &quot;I&quot; &apos; vložit číslo stránky
      if AltSearchPrintOut = &quot;&quot; then &apos; přesměrování není
         nastavVKurzor(prCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac
         &apos; pokud je to blok textu zjistit stranku zacatku bloku 
         select case prCurs.ImplementationName
           case &quot;SwXTextCursor&quot; 
             ovCurs.collapseToStart  &apos; zajíma nás stránka kde to začína, podle původniho viditelného kurzoru
           case &quot;SwXTextTableCursor&quot;  &apos; vybrat text první buňky
             oDocControl.select(ovCurs.Cell)         
          end select           

       else
         nastavVKurzor(oriCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle puvodniho prac
         &apos; pokud je to blok textu zjistit stranku zacatku bloku 
         select case oriCurs.ImplementationName
           case &quot;SwXTextCursor&quot; 
             ovCurs.collapseToStart  &apos; zajíma nás stránka kde to začína, podle původniho viditelného kurzoru
           case &quot;SwXTextTableCursor&quot;  &apos; vybrat text první buňky
             oDocControl.select(ovCurs.Cell)         
          end select           

       end if  

      prCurs.string = cstr(ovCurs.getPage())  &apos; vložit číslo strany začátku
      prCurs.collapseToEnd


    
    case &quot;@&quot; &apos; vložit prostredek velkeho bloku, skupinu
      sk = val(repl(i).nahr) &apos; ciselnou hodnotu skupiny, 0 = cela skupina 
      if sk = 0 then  &apos; vlozit cely vyhledany text 
         if clipbMode then  &apos; vkladat z clipboardu
            if AltSearchPrintOut = &quot;&quot; then &apos; přesměrování není
               goto vlozZclipb
              else &apos; presmerovano
             &apos;  nastavVKurzor(prCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac
               goto vlozZclipbRedir
              end if 

           else  &apos; vkladat pomoci strings
             if hle(0).cmd = &quot;[::BigBlock::]&quot; then  &apos; vložit stred big-bloku
                  &apos; vlozit prostredek bloku
                  prCurs.string = replace_(fo2s,chr(13)+chr(10),chr(13))   &apos; vlozit text #13#10 je odstavec, pri vložení by se přidalo zalomení řádku
                else &apos; smazat obecny objekt
                  prCurs.string = replace_(AltSearchSkup(0),chr(13)+chr(10),chr(13))   &apos; vlozit text #13#10 je odstavec, pri vložení by se přidalo zalomení řádku
                end if 
             prCurs.collapseToEnd
           end if
         
       else &apos; vlozit skupinu 1 - 9
         if sk &lt;=9 then
            prCurs.string = AltSearchSkup(sk)  &apos; vlozit text
            prCurs.collapseToEnd
           end if       
 
       end if  

    case &quot;u&quot; &apos; vložit url odkazu
      if (AltSearchSkup(10) &lt;&gt; &quot;&quot;) then &apos; and(isString(AltSearchSkup(10)))
         prCurs.string = AltSearchSkup(10)  &apos; vlozit URL
         prCurs.collapseToEnd
       end if  

    case &quot;o&quot; &apos; vložit textovy obsah objektu (poznamky, ramce, pole...)
      if (AltSearchSkup(11) &lt;&gt; &quot;&quot;) then 
         &apos; #13#10 je odstavec, pri vložení by se přidalo zalomení řádku
         prCurs.string = replace_(AltSearchSkup(11),chr(13)+chr(10),chr(13))  &apos; textový obsah
         prCurs.collapseToEnd
       end if  

    case &quot;O&quot; &apos; vložit název objektu (poznamky, ramce, pole...)
      if (AltSearchSkup(12) &lt;&gt; &quot;&quot;) then 
         prCurs.string = AltSearchSkup(12)  &apos; nazev objektu
         prCurs.collapseToEnd
       end if  

    case &quot;p&quot; &apos; vložit odstavec
       prCurs.text.insertControlCharacter(prCurs, com.sun.star.text.ControlCharacter.PARAGRAPH_BREAK, false )
       prCurs.collapseToEnd

       &apos; souvisi s posunem kurzoru vlevo při hledani $ - zrušeno, nemělo by být potřeba
       &apos; pokud je poslední úkon nahrazení vložení odstavce, tak posunout doprava na zacatek textu, jinak hrozi zacyklení hledání \p a nahrazení \p..\p 
&apos;       if repl(i).ppos = 1 then 
&apos;&apos;         if (repl(i+1).cmd = &quot;p&quot;) and (prCurs.isStartOfParagraph()) then prCurs.goRight(1,false)  &apos; při použití \p\p v nahrazeni se jinak zacyklí !
&apos;         prCurs.goRight(1,false)  
&apos;        end if


    case &quot;t&quot; &apos; vložit tabulator
       prCurs.string = chr(9)  &apos; vlozit text
       prCurs.collapseToEnd
       
    case &quot;n&quot; &apos; vložit line break 
       prCurs.text.insertControlCharacter(prCurs, com.sun.star.text.ControlCharacter.LINE_BREAK, false )
       prCurs.collapseToEnd

    case &quot;S&quot; &apos; vlozit pevnou mezeru 
       prCurs.text.insertControlCharacter(prCurs, com.sun.star.text.ControlCharacter.HARD_SPACE, false )
       prCurs.collapseToEnd


    case &quot;v&quot;, &quot;V&quot; &apos; vlozit clipboard, vlozit clipboard bez formatu
      if AltSearchPrintOut = &quot;&quot; then &apos; přesměrování není

         nastavVKurzor(prCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac
         if repl(i).cmd = &quot;v&quot; then &apos; vlozit normalne
           vlozZclipb: 
            dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:Paste&quot;, &quot;&quot;, 0, Array())
           else &apos; vlozit bez formatu
            dispathArgs(0).Name = &quot;SelectedFormat&quot;
            dispathArgs(0).Value = 1
            dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:ClipboardFormatItems&quot;, &quot;&quot;, 0, dispathArgs())
           end if 

         &apos; zjistit typ vlozeneho objektu a nastavit oSel objekt pro případnou změnu atributů a prCurs
         select case oDocControl.selection.ImplementationName  &apos; 
           case &quot;SwXTextRanges&quot; &apos; textovy blok nebo tabulka
            &apos; vlozena tabulka?
            markPrac = ovCurs.getEnd() &apos; uložit značku za vlozenym textem nebo tabulkou
            if ovCurs.goleft(1,false) then &apos; viditelny kurzor do tabulky
              if isObject(oDocControl.viewCursor.TextTable) then 
                  &apos; vlozena tabulka
                  selectWholeTable(ovCurs) &apos; vybrat celou vlozenou tabulku
                  oSel = oDocControl.selection  &apos; odkaz na vybrany objekt
                  noTextOb = true
                else 
                  &apos; normálni text, pole nebo objekt jako znak - vybrat 
                  ovCurs.gotoRange(prCurs.getEnd, false) &apos; na zacatek textu
                  ovCurs.gotoRange(markPrac, true) &apos; konec vlozeneho textu
                  noTextOb = false
                end if
            
            prCurs = markPrac.text.createTextCursorByRange(markPrac) &apos; dalsi vkladat za objekt

            end if
 
           &apos; obrazek, textovy ramec,  (vektorova grafika - zlobí)
           case &quot;SwXTextFrame&quot;, &quot;SwXTextGraphicObject&quot;  &apos;, &quot;com.sun.star.drawing.SvxShapeCollection&quot;
             oSel = oDocControl.selection  &apos; odkaz na vybrany objekt ukotveny nekam
             noTextOb = true
         
           &apos; vektorova grafika
           case &quot;com.sun.star.drawing.SvxShapeCollection&quot; 
             &apos; zlobí vypisuje chyby - po vložení nelze ziskat korektni viditelný kyrzor ovCurs
             oSel = oDocControl.selection  &apos; odkaz na vybrany objekt ukotveny nekam
             &apos; on error resume next &apos; pri vybranem grafickem objektu vrací chybu kurzor se nedá vrátit do hlavního
             nastavVKurzor(prCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac           oDocControl.select(prCurs)
&apos;             ovCurs.gotoRange(prCurs.getEnd, false) &apos; na zacatek textu
             noTextOb = true

           case else
             hlaseni1(48, true, false, &quot;ReplDo:  \V \v - insert unknown object:  &quot; &amp; oDocControl.selection.ImplementationName) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
           
          end select 
         obnovVcurs = true &apos; po skonceni vkladani nastavit viditelny kurzor ovCurs podle prCurs, po pouziti clipboardu. 
       
       else &apos; presměrováno
         nastavVKurzor(prCurs1, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac na cilove místo
         if repl(i).cmd = &quot;v&quot; then &apos; vlozit normalne
           vlozZclipbRedir: 
            dispatcher.executeDispatch(oPOfile.getCurrentController().Frame, &quot;.uno:Paste&quot;, &quot;&quot;, 0, Array())
           else &apos; vlozit bez formatu
            dispathArgs(0).Name = &quot;SelectedFormat&quot;
            dispathArgs(0).Value = 1
            dispatcher.executeDispatch(oPOfile.getCurrentController().Frame, &quot;.uno:ClipboardFormatItems&quot;, &quot;&quot;, 0, dispathArgs())
           end if 
         
         &apos; zjistit typ vlozeneho objektu a nastavit oSel objekt pro případnou změnu atributů a prCurs
         select case oPOfile.getCurrentController().selection.ImplementationName  &apos; 
           case &quot;SwXTextRanges&quot; &apos; textovy blok nebo tabulka
            &apos; vlozena tabulka?
            markPrac = ovCurs1.getEnd() &apos; uložit značku za vlozenym textem nebo tabulkou
            if ovCurs1.goleft(1,false) then &apos; viditelny kurzor do tabulky
              if isObject(oPOfile.getCurrentController().viewCursor.TextTable) then 
                  &apos; vlozena tabulka
                  selectWholeTable(ovCurs1) &apos; vybrat celou vlozenou tabulku
                  oSel = oPOfile.getCurrentController().selection  &apos; odkaz na vybrany objekt
                  noTextOb = true
                else 
                  &apos; normálni text, pole nebo objekt jako znak - vybrat 
                  ovCurs1.gotoRange(prCurs1.getEnd, false) &apos; na zacatek textu
                  ovCurs1.gotoRange(markPrac, true) &apos; konec vlozeneho textu
                  noTextOb = false                  
                end if

              prCurs = markPrac.text.createTextCursorByRange(markPrac) &apos; dalsi vkladat za objekt

            end if
 
           &apos; obrazek, textovy ramec,  (vektorova grafika - zlobí)
           case &quot;SwXTextFrame&quot;, &quot;SwXTextGraphicObject&quot;  &apos;, &quot;com.sun.star.drawing.SvxShapeCollection&quot;
             oSel = oPOfile.getCurrentController().selection  &apos; odkaz na vybrany objekt ukotveny nekam
             noTextOb = true
         
           &apos; vektorova grafika
           case &quot;com.sun.star.drawing.SvxShapeCollection&quot; 
             &apos; zlobí vypisuje chyby - po vložení nelze ziskat korektni viditelný kyrzor ovCurs
             oSel = oPOfile.getCurrentController().selection  &apos; odkaz na vybrany objekt ukotveny nekam
             &apos; on error resume next &apos; pri vybranem grafickem objektu vrací chybu kurzor se nedá vrátit do hlavního
             nastavVKurzor(prCurs1, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac           oDocControl.select(prCurs)
&apos;             ovCurs.gotoRange(prCurs.getEnd, false) &apos; na zacatek textu
             noTextOb = true

           case else
             hlaseni1(48, true, false, &quot;ReplDo:  \V \v - insert unknown object:  &quot; &amp; oPOfile.getCurrentController().selection.ImplementationName) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
           
          end select 
         obnovVcurs = true &apos; po skonceni vkladani nastavit viditelny kurzor ovCurs podle prCurs, po pouziti clipboardu. 
       
       end if &apos; presměrováno 
       

    case &quot;M&quot; &apos; zalomeni strany za odstavcem
       prCurs.BreakType = com.sun.star.style.BreakType.PAGE_AFTER &apos;za odstavcem = 5

    case &quot;m&quot; &apos; zalomeni strany pred odstavcem
       prCurs.BreakType = com.sun.star.style.BreakType.PAGE_BEFORE &apos;pred odstavcem = 4

    case &quot;c&quot; &apos; zalomeni sloupce
       prCurs.BreakType = com.sun.star.style.BreakType.COLUMN_BEFORE   &apos; pred = 1; za = 2; oba = 3

    case &quot;r&quot; &apos; zruseni zalomeni zalomeni sloupce - platí pro současny odstavec
       prCurs.BreakType = com.sun.star.style.BreakType.NONE  &apos; = 0

    case &quot;D&quot; &apos; nastavit vsechny properties na vychozí formatovani
       prCurs.gotoRange(markD, true)  &apos; rozsah od konce k posledni pouzite pozici tohoto nastaveni
       markD = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti
       prCurs.setAllPropertiesToDefault()
       prCurs.collapseToEnd

    case &quot;d&quot; &apos; resetuje properties na vychozí formatovani v mistě použití = jakoby se provedlo Ctrl+Shift+mezera
       nastavVKurzor(prCurs.getStart(), false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac na cilove místo
       dispatcher.executeDispatch(oDocControl.Frame, &quot;.uno:ResetAttributes&quot;, &quot;&quot;, 0, Array())
       prCurs.collapseToEnd

    case &quot;h&quot; &apos; nastavi zadanou URL = vytvoří nebo zruší hypelink odkaz z textu 
       prCurs.gotoRange(markH, true)
       markH = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti       
       &apos; umožnit použití parametru \0..\9, &amp;, \u, uvnitř \h{}
       prCurs.HyperLinkURL = SubstValue(repl(i).nahr, prCurs, oriCurs)
       prCurs.collapseToEnd

    case &quot;H&quot; &apos; nahradi podretezec vyhledany v URL (hle(0).pstyl) zadanym retezcem (v repl(i).nahr)
       prCurs.gotoRange(markH, true)
       markH = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti       
       pom = prCurs.HyperLinkURL
       sk = instr(pom,hle(0).pstyl)  
       if sk &gt; 0 then
           pom = left(prCurs.HyperLinkURL,sk-1)
           pom = pom + SubstValue(repl(i).nahr) + right(prCurs.HyperLinkURL, len(prCurs.HyperLinkURL)-len(hle(0).pstyl)-sk+1, prCurs, oriCurs)
           prCurs.HyperLinkURL = pom
         end if
       prCurs.collapseToEnd

    case &quot;P&quot; &apos; nastavi odstavcovy styl 
       prCurs.gotoRange(markP, true)
       markP = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti       
       prCurs.ParaStyleName = repl(i).nahr
       prCurs.collapseToEnd
    
    case &quot;C&quot; &apos; nastavi znakový styl 
       prCurs.gotoRange(markC, true)
       markC = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti       
       prCurs.CharStyleName = repl(i).nahr
       prCurs.collapseToEnd

    case &quot;N&quot; &apos; nastavi styl seznamu
       prCurs.gotoRange(markN, true)
       markN = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti       
       prCurs.NumberingStyleName = repl(i).nahr
       prCurs.collapseToEnd

    case &quot;A&quot; &apos; nastavi zadanou vlastnost - properties
       if noTextOb then 
          &apos; netextovy objekt - menit vlastnosti na oSel 
          &apos; umožnit použití parametru \0..\9, &amp;, \u, \xhhhhh, \#ddddd uvnitř \A{}
          pom = SubstValue(repl(i).nahr, prCurs, oriCurs)
          if not setPropeties(oSel,pom) then errProp = errProp + 1 &apos; pocitadlo chybnych nastaveni properies
          &apos; pokud nenasleduje dalsí prikaz \A tak zrusit nastavovani vlasnosti objektu 
          if i &lt; ubound(repl()) then
             if repl(i+1).cmd &lt;&gt; &quot;A&quot; then noTextOb = false &apos; dalsi nahrada je textova, vratit do textoveho rezimu
            end if

         else 
          &apos; textovy rozsah - menit vlatnosti na prCurs
          prCurs.gotoRange(markProp, true)
          &apos; pokud nenasleduje dalsí prikaz \A tak ulozit posledni pozici pro dalsi pouziti
          if i &lt; ubound(repl()) then
             if repl(i+1).cmd &lt;&gt; &quot;A&quot; then markProp = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti
            end if

          if not setPropeties(prCurs,repl(i).nahr) then errProp = errProp + 1 &apos; pocitadlo chybnych nastaveni properies
          prCurs.collapseToEnd
         end if 


    case &quot;F&quot; &apos; vloží poznamku pod čarou 
       &apos; vytvořit novou poznámku
       oFoot = AltSearchDoc.createInstance(&quot;com.sun.star.text.Footnote&quot;)
       &apos; zařadit do dokumentu 
       oFoot.attach(prCurs.End)
       prCurs.collapseToEnd 
       mistochyby = &quot;F&quot;  &apos; identifikace místa chyby
       &apos; naplnit ovsah poznamky 
       oFootCurs = oFoot.createTextCursor
&apos;       oFootCurs.gotoStart(false)
&apos;       oFootCurs.setString(&quot;The &quot;)
&apos;       oFootCurs.gotoEnd(false)
&apos;       oFootCurs.CharWeight = com.sun.star.awt.FontWeight.BOLD
&apos;       oFootCurs.setString(&quot;famous&quot;)
&apos;       oFootCurs.gotoEnd(false)
&apos;       oFootCurs.CharWeight = com.sun.star.awt.FontWeight.NORMAL
&apos;       oFootCurs.setString(&quot; German Chancellor&quot;)

       &apos; umožnit použití parametru \0..\9, &amp;, \u, \xhhhhh, \#ddddd uvnitř \h{}
       oFootCurs.string = SubstValue(repl(i).nahr, prCurs, oriCurs)


    case &quot;E&quot; &apos; vloží poznamku na konci
       &apos; vytvořit novou poznámku
       oFoot = AltSearchDoc.createInstance(&quot;com.sun.star.text.Endnote&quot;)
       &apos; zařadit do dokumentu 
       oFoot.attach(prCurs.End)
       prCurs.collapseToEnd 
       mistochyby = &quot;E&quot;  &apos; identifikace místa chyby
       &apos; naplnit ovsah poznamky 
       oFootCurs = oFoot.createTextCursor
       &apos; umožnit použití parametru \0..\9, &amp;, \u, \xhhhhh, \#ddddd uvnitř \h{}
       oFootCurs.string = SubstValue(repl(i).nahr, prCurs, oriCurs)



    case &quot;B&quot; &apos; vloží značku a text pro křížový odkaz:    značka|text 
       &apos; vytvořit novou značku
       oFoot = AltSearchDoc.createInstance(&quot;com.sun.star.text.ReferenceMark&quot;)
       &apos; zařadit do dokumentu 
       pom = SubstValue(repl(i).nahr, prCurs, oriCurs) &apos; parametr
       if instr(pom,&quot;|&quot;)&lt;1 then pom = pom + &quot;|&quot;  &apos; pokud neni separátor tak se to považuje za značku
       prCurs.string = rightPast(pom,&quot;|&quot;) &apos; vložit text  
       pom = leftTo(pom,&quot;|&quot;) &apos; značka
       oFoot.Name = pom
       if AltSearchDoc.ReferenceMarks.hasByName(pom) then  &apos; toto jmeno uz existuje
          hlaseni1(64, true, false, msg(39)) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti           
         else
          prCurs.Text.insertTextContent(prCurs, oFoot, True)         
         end if 

       prCurs.collapseToEnd  


    case &quot;K&quot; &apos; vloží záložku (bookmark) zadaneho jmena; parametry w = celý blok,  b = jen na začátku bloku, e = jen na konci bloku 
       &apos; zjistit parametr
       pom = SubstValue(repl(i).nahr, prCurs, oriCurs)
       pom1 = trim(leftTo(pom,&quot;,&quot;))  &apos; parametr
       pom = rightPast(pom,&quot;,&quot;)      &apos; jmeno

       prCurs.gotoRange(markK, true)  &apos; nastavit prac kurzor na poslední značku (poprve rozsah celeho nalezeneho retezce) 
       markK = prCurs.getEnd()  &apos; ulozit posledni pozici pro dalsi pouziti tehož parametru 

       &apos; vytvořit promennou založky
       oFoot = AltSearchDoc.createInstance(&quot;com.sun.star.text.Bookmark&quot;)
       oFoot.Name = SubstValue(pom, prCurs, oriCurs) &apos; parametr s vloženými hodnotami &amp; \0-\9 \i a pod.
 
       if oFoot.Name = &quot;&quot; then  &apos; prazdné jmeno = smazat založku, pokud je na místě kurzoru

          &apos;potvrdit zda byl kurzor na nějaké záložce, pokud ano tak smazat
          if FoundBookmarkNo &gt;= 0 then 
&apos;             hlaseni1(64, true, false, &quot;mažu záložku  &quot; + AltSearchSkup(12)) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti           
&apos;             xray AltsearchDoc.Bookmarks.getByIndex(FoundBookmarkNo)
             AltsearchDoc.Bookmarks.getByName(AltSearchSkup(12)).dispose
             FoundBookmarkNo = -1  &apos; po smazanem hledat znovu
           end if
          
         else  &apos; zařadit založku do dokumentu          
           &apos; prcurs ma nastaveny rozsah nalezeneho nebo doposud nahrazeneho textu
           select case pom1  &apos; první parametr - w,b,e = způsob vložení bloku
            case &quot;b&quot;  
              prCurs.collapseToStart  &apos; vložit na začátek
            case &quot;e&quot;
              prCurs.collapseToEnd    &apos; vložit na konec
            end select

           prCurs.Text.insertTextContent(prCurs, oFoot, True)
         end if 
   
       prCurs.gotoRange(markK, false)  &apos; obnovit polohu kurzoru na konec, pokud byl použit parametr &quot;b&quot; 
       prCurs.collapseToEnd 


    case &quot;L&quot; &apos; vloží křížový odkaz 
       &apos; vytvořit novou značku
       oFoot = AltSearchDoc.createInstance(&quot;com.sun.star.text.TextField.GetReference&quot;)
       pom = SubstValue(repl(i).nahr, prCurs, oriCurs)
       oFoot.ReferenceFieldPart = val(leftTo(pom,&quot;,&quot;))  &apos; první parametr - typ zobrazení odkazu (stránka, kapitola, ...)
       pom = rightPast(pom,&quot;,&quot;)
       oFoot.ReferenceFieldSource = val(leftTo(pom,&quot;,&quot;)) &apos; druhý parametr - typ zdroje odkazu (značka reference, )
       oFoot.SourceName = rightPast(pom,&quot;,&quot;)

       &apos; zařadit do dokumentu 
       oFoot.attach(prCurs.End)
       prCurs.collapseToEnd 
       textFields = true
       


    case &quot;!&quot; &apos; chyba, skončit
      goto konec

    case else  
 
    end select
 
 pokracuj:
 
 
  next i &apos; konec cyklu pro všechny zaznamy pro nahrazeni

   &apos; přesměrování nahrazeni (\R) do okna/ramce AltSearchPrintOut ?
   if AltSearchPrintOut &lt;&gt; &quot;&quot; then &apos; přesměrování ano
      ReastoreFrameName &apos; po zápisu nutno obnovit identifikator pokud neni soubor ulozen 
      &apos;nastavi viditelny kurzor ve vypisu podle pracovniho
      oPOfile.CurrentController.select(prCurs)    &apos; vybrat konec  

      &apos; nastavit původní prCurs pro dalši hledani/nahrazeni 
      prCurs = oriCurs
      &apos; prCurs vypisu na konec
      prCurs1.gotoEnd(false) 

      if noTextOb then goto preskoc
    end if 

    &apos; nastavit prCurs pro dalši hledani/nahrazeni 
    if AltSearchVolby.zpet = 1 then 
         prCurs.gotoRange(Bmark, false)
      else &apos;prozatim, po nahrade by mel byt kurzor za poslednim vloženym znakem 
         mistochyby = &quot;nastavPrCurs&quot; &apos; zde to při použití \R na poznamky hazelo chyby
         prCurs.gotoRange(prCurs.getEnd(), false)
         nastavPrCurs:
      end if
 
    if obnovVcurs then nastavVKurzor(prCurs, false, &quot;&quot;)  &apos;nastavit viditelny kurzor podle prac
 preskoc:
    
  
&apos;dbgVcursor(Bmark,prCurs.getEnd(),&quot;Stop&quot;)

konec:
&apos; HledamDisp(false) &apos; pristupne hledani 
 exit sub
 
nejakaChyba:
  select case mistochyby 
    case &quot;F&quot;, &quot;E&quot; &apos; chyba při vytvoření poznamky
       hlaseni1(64, true, false, msg(38)) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
       mistochyby = &quot;&quot;
       goto pokracuj
    case &quot;nastavPrCurs&quot; &apos; chyba při 
       mistochyby = &quot;&quot;
 &apos;      goto nastavPrCurs
    case else
       hlaseni1(48, true, false, &quot;ReplDo:  Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti    
    end select   
end sub



&apos;************************** Insert the item text ****************************
sub subInsertReference(nRefType as integer, sRefname as string, nPart as integer, oCurText as object, oViewCursor as object)
dim oRefField as object

oRefField = oDoc.createInstance(&quot;com.sun.star.text.TextField.GetReference&quot;)
oRefField.ReferenceFieldSource = nRefType
oRefField.SourceName = sRefname
oRefField.ReferenceFieldPart = nPart
oCurText.insertTextContent(oViewCursor, oRefField, false)
end sub



&apos; otevre seznam - není funkce která by dokazalo rozbalit seznam???
sub TfindReg
&apos;oDial.getcontrol(&quot;Cb_findReg&quot;).Visible = true
&apos;xray oDial.getcontrol(&quot;Cb_findReg&quot;)
&apos;xray thiscomponent
end sub

&apos; otevre seznam - není funkce která by dokazalo rozbalit seznam???
sub TfindExt

end sub


&apos; otevre seznam
sub TReplExt

end sub





&apos; vraci strukturovanou promenou jako retezec jemeno = hodnota,  odeleny  oddelovacem SEP  
sub getStructValues(oSe as object,jmeno as string)as string
dim OOoReflection, pom, i, struct, vysl, valu 
const sep as string = &quot; &quot;
 if errControl then on error resume next
 &apos; zjisteni UNO jmena - struct nebo implementName
 OOoReflection = CreateUnoService(&quot;com.sun.star.reflection.CoreReflection&quot;) &apos; pomocny objekt
 pom = oSe.GetPropertyValue(jmeno)
&apos; xray pom
 &apos; pole se jmeny promennych
 struct = OOoReflection.getType(pom).Fields

 for i = lbound(struct) to ubound(struct())
    valu = &quot;&quot;  &apos; predpoklada se nulova hodnota
    &apos; v pripade ze hodnota je opet struct, tak obsluha chyby 
    &apos; prekočí na dalsi radek a jako hodnota se pouzije prazdny retezec
    valu = cstr(struct(i).get(pom))  
    vysl = vysl &amp; struct(i).name &amp; &quot;=&quot; &amp; valu &amp; sep
  next i

 vysl = left(vysl,len(vysl)-1) &apos; bez posledniho oddelovace
 getStructValues = vysl
end sub


&apos; vraci retezec value podle hledaneho name
sub getValString(ret,nam$) as string 
const sep as string = &quot; &quot;  &apos; oddelovac jednotlivych zaznamu
dim pom, val

 pom = rightPast(ret, nam+&quot;=&quot;)+ sep &apos; čast bezprostředne za jmeno + &quot;=&quot;
 getValString = leftTo(pom,sep)
end sub



sub setPropeties(oObj as object, prop as string)as boolean
dim nam$, pom, valu
 if errControl then on error goto konec
 setPropeties = true
 nam = leftTo(prop,&quot;: &quot;)
 if nam&lt;&gt;&quot;&quot; then  &apos; promena typu zaznam
    pom = rightPast(prop,&quot;: &quot;) &apos; pouze cast retezce s hodnotami
    valu = oObj.getPropertyValue(nam)
    select case nam
     case &quot;BottomBorder&quot;, &quot;TopBorder&quot;, &quot;LeftBorder&quot;, &quot;RightBorder&quot; &apos; Color=0 InnerLineWidth=0 OuterLineWidth=0 LineDistance=0
       valu.Color = getPrValue(getValString(pom,&quot;Color&quot;))
       valu.InnerLineWidth = getPrValue(getValString(pom,&quot;InnerLineWidth&quot;))
       valu.OuterLineWidth = getPrValue(getValString(pom,&quot;OuterLineWidth&quot;))
       valu.LineDistance = getPrValue(getValString(pom,&quot;LineDistance&quot;))
      
     case &quot;CharLocale&quot;, &quot;CharLocaleAsian&quot;, &quot;CharLocaleComplex&quot; &apos; CharLocale: Language=cs Country=CZ Variant=
       valu.Language = getPrValue(getValString(pom,&quot;Language&quot;))
       valu.Variant = getPrValue(getValString(pom,&quot;Variant&quot;))
     
     case &quot;DropCapFormat&quot; &apos; DropCapFormat: Lines=0 Count=0 Distance=0
       valu.Lines = getPrValue(getValString(pom,&quot;Lines&quot;))
       valu.Count = getPrValue(getValString(pom,&quot;Count&quot;))
       valu.Distance = getPrValue(getValString(pom,&quot;Distance&quot;))
     
     case &quot;ParaLineSpacing&quot; &apos;ParaLineSpacing: Mode=0 Height=100
       valu.Mode = getPrValue(getValString(pom,&quot;Mode&quot;))
       valu.Height = getPrValue(getValString(pom,&quot;Height&quot;))
     
     case &quot;ParaShadowFormat&quot;, &quot;ShadowFormat&quot; &apos; ParaShadowFormat: Location=0 ShadowWidth=176 IsTransparent=False Color=8421504 
       valu.Location = getPrValue(getValString(pom,&quot;Location&quot;))
       valu.ShadowWidth = getPrValue(getValString(pom,&quot;ShadowWidth&quot;))
       valu.IsTransparent = getPrValue(getValString(pom,&quot;IsTransparent&quot;))
       valu.Color = getPrValue(getValString(pom,&quot;Color&quot;))

     case &quot;Size&quot;  &apos; Size: Width=4140 Height=2138}
       valu.Width = getPrValue(getValString(pom,&quot;Width&quot;))
       valu.Height = getPrValue(getValString(pom,&quot;Height&quot;))     

         
     end select
    
    oObj.setPropertyValue(nam,valu)

 
   else  &apos; normalni jednoducha properties, mela by jit nastavit   
    nam = leftTo(prop,&quot;=&quot;)
&apos;    valu = oObj.getPropertyValue(nam)
    pom = rightPast(prop,&quot;=&quot;)
    pom = getPrValue(pom)
    select case nam
     case &quot;Name&quot;
       oObj.setName(pom)
     case else
       oObj.setPropertyValue(nam,pom) 
     end select 
    
   end if


 exit sub
 
konec:
 setPropeties = false 
end sub





&apos; nacte do  Cb_replAtr  seznam vlastnosti vybraneho objektu
sub Bt_loadAtr
 dim prop, oSe, sezn
 dim pom, i, ppol()
 oDial.model.Cb_loadAtr.enabled = false  &apos; po dobu prace deaktivovat
 if errControl then on error resume next   &apos; kvuli chybe properties &quot;ClientMap&quot; u textoveho ramce 

 sezn = oDial.getcontrol(&quot;Cb_replAtr&quot;) &apos;. addItem(&quot;Vlozeno&quot;, 0)
 oSe = AltSearchDoc.getCurrentController.getSelection

 select case oSe.ImplementationName
   case &quot;SwXTextRanges&quot;,&quot;com.sun.star.drawing.SvxShapeCollection&quot;
     &apos; pole se seznamem properties
     oSe= AltSearchDoc.getCurrentController.getSelection.getByIndex(0)
     
   case &quot;SwXTextGraphicObject&quot;,&quot;SwXTextFrame&quot;,&quot;SwXTextTableCursor&quot;, &quot;SwXTextEmbeddedObject&quot;
     
   case else
     hlaseni1(32, true, false, &quot;Bt_loadAtr:  Unknown object: &quot; + oSe.ImplementationName) &apos;  styl: 16=zastavit 32=? 48=! 64=info; moznopotlačit; prerusit cinnosti
     goto konec 

   end select
  
 prop = oSe.PropertySetInfo.Properties

 &apos; zrusit stary seznam
 sezn.removeItems(0, sezn.ItemCount) 
 for i = 0 to ubound(prop())  &apos; projít všechny properties
     pom =&quot;&quot;
     
     if prop(i).name = &quot;Name&quot; then xray  prop(i)
     &apos; neni property read only?
     if (not((prop(i).Attributes and 16) = 16)) then 
        
        select case prop(i).type.TypeClass     
         &apos; .type.TypeClass: 2-boolean, 3-byte, 4-short, 6-long, 10-float, 11-double, 12-string
         &apos;                 15-konstanta OOo, 17-struct, 20-pole []string, 22-events, index???
          case 2,3,4,6,10,11,12,15
            pom = prop(i).name &amp;  &quot; = &quot; &amp; oSe.GetPropertyValue(prop(i).name)           
            sezn.addItem(pom, sezn.ItemCount)
          
          case 17  &apos; struct
            pom = prop(i).name + &quot;: &quot; + getStructValues(oSe,prop(i).name)
            sezn.addItem(pom, sezn.ItemCount)

          case 20, 22  &apos; pole, events - ignorovat

          case else  &apos; zbytek - ignorovat
            
        end  select  
      end if
   
   next i

 pom = &quot;&quot;
 pom = oSe.getName()
 if pom&lt;&gt;&quot;&quot; then sezn.addItem(&quot;Name = &quot;+pom, sezn.ItemCount)
 

 ppol() = BubbleSortList_(sezn.items) &apos; uložit kvuli trideni
 sezn.removeItems(0, sezn.ItemCount)  &apos; zrusit stary seznam
 sezn.addItems(ppol(),0)  &apos; načíst setrideny
 sezn.addItem(msg(22),0)  &apos; prvni polozka = Help: Aktualizujte seznam pomocí tlačítka vlevo.   

konec:
 oDial.model.Cb_loadAtr.enabled = true &apos; aktivovat
end sub




&apos; uloži historii hledani a nahrad ze zaznamů do globálních polí
sub ulozHistorii
dim tmp
  &apos; ulozit historii hledani do pole   
  redim AltSearchFind() 
  tmp = oDial.getControl(&quot;Cb_find&quot;) &apos; seznam historie
&apos;  tmp.addItem(0,oDial.model.Cb_find.text) &apos; ulozit posledni hledání na index 0
  AltSearchFind() = tmp.getItems()
  &apos; ulozit historii nahrazeni do pole   
  redim AltSearchrepl() 
  tmp = oDial.getControl(&quot;Cb_repl&quot;) &apos; seznam historie
&apos;  tmp.additem(0,oDial.model.Cb_repl.text) &apos; ulozit posledni hledání na index 0
  AltSearchRepl() = tmp.getItems()

end sub





sub KonecTm

  &apos; ulozit polohu
  if errControl then on error resume next
  if findcounter &gt; 0 then &apos; prerusit hledani
      findcounter = -999 
      exit sub
     end if 

  AltSearchIni(1) = oDial.PosSize.X  
  AltSearchIni(2) = oDial.PosSize.Y
  AltSearchIni(3) = oDial.model.Ch_case.state &apos; case sensitive
  AltSearchIni(4) = oDial.model.Ch_word.state &apos; celá slova 
  AltSearchIni(5) = oDial.model.Ch_reg.state  &apos; regularni vyrazy
  AltSearchIni(6) = oDial.model.Ch_zpet.state &apos; pozpatku
  AltSearchIni(7) = oDial.model.Ch_styl.state &apos; hledat styly 
  AltSearchIni(10) = oDial.model.Ch_preservecap.state &apos; zachovat velka písmena 

  AltSearchIni(8) = AltSearchVolby.find  
  AltSearchIni(9) = AltSearchVolby.repl
  
  ulozHistorii &apos; uloži historii hledani a nahrad ze zaznamů do globálních polí

  AltSearchDialog_end = true
  AltSearchDocControl.removeKeyHandler(AltSearchKbd) &apos; aby nezustala viset klavesnice

end sub



Sub AltSearchDlg_windowActivated(oEv)
 &apos; proc false ??? - asi proto abu při ztrátě a obnovení focusu bez zásahu do dokumentu
 &apos; se nepřepsaly hranice půcodního výběru? 
 CursorInit(false) &apos; inicializace pozic kurzoru a bloku

End Sub

Sub AltSearchDlg_windowDeactivated(oEv)
End Sub

Sub AltSearchDlg_windowOpened(oEv)
End Sub

Sub AltSearchDlg_windowClosing(oEv)
 KonecTm
End Sub

Sub AltSearchDlg_windowClosed(oEv)
End Sub

Sub AltSearchDlg_windowMinimized(oEv)
End Sub

Sub AltSearchDlg_windowNormalized(oEv)
End Sub

Sub AltSearchDlg_disposing(oEv)
End Sub


&apos; Obsluha stlacene klavesy
function AltSearchKbd_KeyPressed(oEvt) as boolean
&apos;   beep
 if oEvt.KeyChar = chr(27) then &apos; prerušit hledání
    beep
    findcounter = -999
   end if
 AltSearchKbd_KeyPressed = false &apos;false jinak nechat puvodni obsluhu; true = nevolá puvodni obsluhu 
end function


function AltSearchKbd_KeyReleased(oEvt) as boolean
&apos; Obsluha uvolnene klávesy
 AltSearchKbd_KeyReleased = false  
end function


function AltSearchKbd_disposing(oEvt) 
end function


&apos; nastavi viditelny kurzor podle rozsahu
sub dbgVcursor(zac,kon, msg1)
 on error goto chyba
 &apos; nastavit viditelny kurzor podle neviditelneho    
 ovCurs.gotoRange(zac,false)
 ovCurs.gotoRange(kon,true)
 msgbox msg1
 exit sub
 
chyba:
 msgbox &quot;dbgVcursor:  Asi chyba regionu, kurzoru.&quot; 
end sub


&apos; vypise pole se skupinami pro nahrazeni
sub dbgVypisSkupiny
dim i , ms
 ms = &quot;&quot;
 for i = 0 to ubound(AltSearchSkup())
    ms = ms &amp; i &amp; &quot;:  &gt;&quot; &amp; AltSearchSkup(i) &amp; &quot;&lt; &quot; &amp; chr(10) 
  next i

 msgbox ms
end sub





</script:module>